// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"kubecit-service/ent/account"
	"kubecit-service/ent/applyrecord"
	"kubecit-service/ent/category"
	"kubecit-service/ent/chapter"
	"kubecit-service/ent/course"
	"kubecit-service/ent/lesson"
	"kubecit-service/ent/orderinfos"
	"kubecit-service/ent/orders"
	"kubecit-service/ent/predicate"
	"kubecit-service/ent/setting"
	"kubecit-service/ent/slider"
	"kubecit-service/ent/teacher"
	"kubecit-service/ent/user"
	"kubecit-service/ent/vipinfo"
	"kubecit-service/ent/viporder"
	"kubecit-service/ent/vipproduct"
	"kubecit-service/ent/wallet"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount     = "Account"
	TypeApplyRecord = "ApplyRecord"
	TypeCategory    = "Category"
	TypeChapter     = "Chapter"
	TypeCourse      = "Course"
	TypeLesson      = "Lesson"
	TypeOrderInfos  = "OrderInfos"
	TypeOrders      = "Orders"
	TypeSetting     = "Setting"
	TypeSlider      = "Slider"
	TypeTeacher     = "Teacher"
	TypeUser        = "User"
	TypeVipInfo     = "VipInfo"
	TypeVipOrder    = "VipOrder"
	TypeVipProduct  = "VipProduct"
	TypeWallet      = "Wallet"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *uint64
	adduser_id    *int64
	openid        *string
	password      *string
	method        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Account, error)
	predicates    []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AccountMutation) SetUserID(u uint64) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountMutation) UserID() (r uint64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *AccountMutation) AddUserID(u int64) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AccountMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOpenid sets the "openid" field.
func (m *AccountMutation) SetOpenid(s string) {
	m.openid = &s
}

// Openid returns the value of the "openid" field in the mutation.
func (m *AccountMutation) Openid() (r string, exists bool) {
	v := m.openid
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenid returns the old "openid" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldOpenid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenid: %w", err)
	}
	return oldValue.Openid, nil
}

// ResetOpenid resets all changes to the "openid" field.
func (m *AccountMutation) ResetOpenid() {
	m.openid = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
}

// SetMethod sets the "method" field.
func (m *AccountMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *AccountMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AccountMutation) ResetMethod() {
	m.method = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user_id != nil {
		fields = append(fields, account.FieldUserID)
	}
	if m.openid != nil {
		fields = append(fields, account.FieldOpenid)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.method != nil {
		fields = append(fields, account.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldUserID:
		return m.UserID()
	case account.FieldOpenid:
		return m.Openid()
	case account.FieldPassword:
		return m.Password()
	case account.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldUserID:
		return m.OldUserID(ctx)
	case account.FieldOpenid:
		return m.OldOpenid(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case account.FieldOpenid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenid(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, account.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldUserID:
		m.ResetUserID()
		return nil
	case account.FieldOpenid:
		m.ResetOpenid()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Account edge %s", name)
}

// ApplyRecordMutation represents an operation that mutates the ApplyRecord nodes in the graph.
type ApplyRecordMutation struct {
	config
	op               Op
	typ              string
	id               *int
	detail           *string
	curriculum_vitae *string
	works            *string
	skills           *string
	name             *string
	level            *int
	addlevel         *int
	avatar           *string
	create_at        *time.Time
	update_at        *time.Time
	is_passed        *int8
	addis_passed     *int8
	messages         *string
	auditor_id       *int
	addauditor_id    *int
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*ApplyRecord, error)
	predicates       []predicate.ApplyRecord
}

var _ ent.Mutation = (*ApplyRecordMutation)(nil)

// applyrecordOption allows management of the mutation configuration using functional options.
type applyrecordOption func(*ApplyRecordMutation)

// newApplyRecordMutation creates new mutation for the ApplyRecord entity.
func newApplyRecordMutation(c config, op Op, opts ...applyrecordOption) *ApplyRecordMutation {
	m := &ApplyRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeApplyRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplyRecordID sets the ID field of the mutation.
func withApplyRecordID(id int) applyrecordOption {
	return func(m *ApplyRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *ApplyRecord
		)
		m.oldValue = func(ctx context.Context) (*ApplyRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApplyRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplyRecord sets the old ApplyRecord of the mutation.
func withApplyRecord(node *ApplyRecord) applyrecordOption {
	return func(m *ApplyRecordMutation) {
		m.oldValue = func(context.Context) (*ApplyRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplyRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplyRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplyRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplyRecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApplyRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDetail sets the "detail" field.
func (m *ApplyRecordMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *ApplyRecordMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *ApplyRecordMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[applyrecord.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *ApplyRecordMutation) DetailCleared() bool {
	_, ok := m.clearedFields[applyrecord.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *ApplyRecordMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, applyrecord.FieldDetail)
}

// SetCurriculumVitae sets the "curriculum_vitae" field.
func (m *ApplyRecordMutation) SetCurriculumVitae(s string) {
	m.curriculum_vitae = &s
}

// CurriculumVitae returns the value of the "curriculum_vitae" field in the mutation.
func (m *ApplyRecordMutation) CurriculumVitae() (r string, exists bool) {
	v := m.curriculum_vitae
	if v == nil {
		return
	}
	return *v, true
}

// OldCurriculumVitae returns the old "curriculum_vitae" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldCurriculumVitae(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurriculumVitae is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurriculumVitae requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurriculumVitae: %w", err)
	}
	return oldValue.CurriculumVitae, nil
}

// ClearCurriculumVitae clears the value of the "curriculum_vitae" field.
func (m *ApplyRecordMutation) ClearCurriculumVitae() {
	m.curriculum_vitae = nil
	m.clearedFields[applyrecord.FieldCurriculumVitae] = struct{}{}
}

// CurriculumVitaeCleared returns if the "curriculum_vitae" field was cleared in this mutation.
func (m *ApplyRecordMutation) CurriculumVitaeCleared() bool {
	_, ok := m.clearedFields[applyrecord.FieldCurriculumVitae]
	return ok
}

// ResetCurriculumVitae resets all changes to the "curriculum_vitae" field.
func (m *ApplyRecordMutation) ResetCurriculumVitae() {
	m.curriculum_vitae = nil
	delete(m.clearedFields, applyrecord.FieldCurriculumVitae)
}

// SetWorks sets the "works" field.
func (m *ApplyRecordMutation) SetWorks(s string) {
	m.works = &s
}

// Works returns the value of the "works" field in the mutation.
func (m *ApplyRecordMutation) Works() (r string, exists bool) {
	v := m.works
	if v == nil {
		return
	}
	return *v, true
}

// OldWorks returns the old "works" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldWorks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorks: %w", err)
	}
	return oldValue.Works, nil
}

// ClearWorks clears the value of the "works" field.
func (m *ApplyRecordMutation) ClearWorks() {
	m.works = nil
	m.clearedFields[applyrecord.FieldWorks] = struct{}{}
}

// WorksCleared returns if the "works" field was cleared in this mutation.
func (m *ApplyRecordMutation) WorksCleared() bool {
	_, ok := m.clearedFields[applyrecord.FieldWorks]
	return ok
}

// ResetWorks resets all changes to the "works" field.
func (m *ApplyRecordMutation) ResetWorks() {
	m.works = nil
	delete(m.clearedFields, applyrecord.FieldWorks)
}

// SetSkills sets the "skills" field.
func (m *ApplyRecordMutation) SetSkills(s string) {
	m.skills = &s
}

// Skills returns the value of the "skills" field in the mutation.
func (m *ApplyRecordMutation) Skills() (r string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldSkills(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// ClearSkills clears the value of the "skills" field.
func (m *ApplyRecordMutation) ClearSkills() {
	m.skills = nil
	m.clearedFields[applyrecord.FieldSkills] = struct{}{}
}

// SkillsCleared returns if the "skills" field was cleared in this mutation.
func (m *ApplyRecordMutation) SkillsCleared() bool {
	_, ok := m.clearedFields[applyrecord.FieldSkills]
	return ok
}

// ResetSkills resets all changes to the "skills" field.
func (m *ApplyRecordMutation) ResetSkills() {
	m.skills = nil
	delete(m.clearedFields, applyrecord.FieldSkills)
}

// SetName sets the "name" field.
func (m *ApplyRecordMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApplyRecordMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApplyRecordMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *ApplyRecordMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *ApplyRecordMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *ApplyRecordMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *ApplyRecordMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *ApplyRecordMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetAvatar sets the "avatar" field.
func (m *ApplyRecordMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *ApplyRecordMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *ApplyRecordMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[applyrecord.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *ApplyRecordMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[applyrecord.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *ApplyRecordMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, applyrecord.FieldAvatar)
}

// SetCreateAt sets the "create_at" field.
func (m *ApplyRecordMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *ApplyRecordMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *ApplyRecordMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *ApplyRecordMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *ApplyRecordMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *ApplyRecordMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetIsPassed sets the "is_passed" field.
func (m *ApplyRecordMutation) SetIsPassed(i int8) {
	m.is_passed = &i
	m.addis_passed = nil
}

// IsPassed returns the value of the "is_passed" field in the mutation.
func (m *ApplyRecordMutation) IsPassed() (r int8, exists bool) {
	v := m.is_passed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPassed returns the old "is_passed" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldIsPassed(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPassed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPassed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPassed: %w", err)
	}
	return oldValue.IsPassed, nil
}

// AddIsPassed adds i to the "is_passed" field.
func (m *ApplyRecordMutation) AddIsPassed(i int8) {
	if m.addis_passed != nil {
		*m.addis_passed += i
	} else {
		m.addis_passed = &i
	}
}

// AddedIsPassed returns the value that was added to the "is_passed" field in this mutation.
func (m *ApplyRecordMutation) AddedIsPassed() (r int8, exists bool) {
	v := m.addis_passed
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsPassed resets all changes to the "is_passed" field.
func (m *ApplyRecordMutation) ResetIsPassed() {
	m.is_passed = nil
	m.addis_passed = nil
}

// SetMessages sets the "messages" field.
func (m *ApplyRecordMutation) SetMessages(s string) {
	m.messages = &s
}

// Messages returns the value of the "messages" field in the mutation.
func (m *ApplyRecordMutation) Messages() (r string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldMessages(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// ClearMessages clears the value of the "messages" field.
func (m *ApplyRecordMutation) ClearMessages() {
	m.messages = nil
	m.clearedFields[applyrecord.FieldMessages] = struct{}{}
}

// MessagesCleared returns if the "messages" field was cleared in this mutation.
func (m *ApplyRecordMutation) MessagesCleared() bool {
	_, ok := m.clearedFields[applyrecord.FieldMessages]
	return ok
}

// ResetMessages resets all changes to the "messages" field.
func (m *ApplyRecordMutation) ResetMessages() {
	m.messages = nil
	delete(m.clearedFields, applyrecord.FieldMessages)
}

// SetAuditorID sets the "auditor_id" field.
func (m *ApplyRecordMutation) SetAuditorID(i int) {
	m.auditor_id = &i
	m.addauditor_id = nil
}

// AuditorID returns the value of the "auditor_id" field in the mutation.
func (m *ApplyRecordMutation) AuditorID() (r int, exists bool) {
	v := m.auditor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorID returns the old "auditor_id" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldAuditorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorID: %w", err)
	}
	return oldValue.AuditorID, nil
}

// AddAuditorID adds i to the "auditor_id" field.
func (m *ApplyRecordMutation) AddAuditorID(i int) {
	if m.addauditor_id != nil {
		*m.addauditor_id += i
	} else {
		m.addauditor_id = &i
	}
}

// AddedAuditorID returns the value that was added to the "auditor_id" field in this mutation.
func (m *ApplyRecordMutation) AddedAuditorID() (r int, exists bool) {
	v := m.addauditor_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAuditorID clears the value of the "auditor_id" field.
func (m *ApplyRecordMutation) ClearAuditorID() {
	m.auditor_id = nil
	m.addauditor_id = nil
	m.clearedFields[applyrecord.FieldAuditorID] = struct{}{}
}

// AuditorIDCleared returns if the "auditor_id" field was cleared in this mutation.
func (m *ApplyRecordMutation) AuditorIDCleared() bool {
	_, ok := m.clearedFields[applyrecord.FieldAuditorID]
	return ok
}

// ResetAuditorID resets all changes to the "auditor_id" field.
func (m *ApplyRecordMutation) ResetAuditorID() {
	m.auditor_id = nil
	m.addauditor_id = nil
	delete(m.clearedFields, applyrecord.FieldAuditorID)
}

// SetUserID sets the "user_id" field.
func (m *ApplyRecordMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ApplyRecordMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ApplyRecord entity.
// If the ApplyRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplyRecordMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ApplyRecordMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[applyrecord.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ApplyRecordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[applyrecord.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ApplyRecordMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, applyrecord.FieldUserID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ApplyRecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ApplyRecordMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ApplyRecordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ApplyRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ApplyRecordMutation builder.
func (m *ApplyRecordMutation) Where(ps ...predicate.ApplyRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplyRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplyRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApplyRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplyRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplyRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApplyRecord).
func (m *ApplyRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplyRecordMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.detail != nil {
		fields = append(fields, applyrecord.FieldDetail)
	}
	if m.curriculum_vitae != nil {
		fields = append(fields, applyrecord.FieldCurriculumVitae)
	}
	if m.works != nil {
		fields = append(fields, applyrecord.FieldWorks)
	}
	if m.skills != nil {
		fields = append(fields, applyrecord.FieldSkills)
	}
	if m.name != nil {
		fields = append(fields, applyrecord.FieldName)
	}
	if m.level != nil {
		fields = append(fields, applyrecord.FieldLevel)
	}
	if m.avatar != nil {
		fields = append(fields, applyrecord.FieldAvatar)
	}
	if m.create_at != nil {
		fields = append(fields, applyrecord.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, applyrecord.FieldUpdateAt)
	}
	if m.is_passed != nil {
		fields = append(fields, applyrecord.FieldIsPassed)
	}
	if m.messages != nil {
		fields = append(fields, applyrecord.FieldMessages)
	}
	if m.auditor_id != nil {
		fields = append(fields, applyrecord.FieldAuditorID)
	}
	if m.user != nil {
		fields = append(fields, applyrecord.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplyRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case applyrecord.FieldDetail:
		return m.Detail()
	case applyrecord.FieldCurriculumVitae:
		return m.CurriculumVitae()
	case applyrecord.FieldWorks:
		return m.Works()
	case applyrecord.FieldSkills:
		return m.Skills()
	case applyrecord.FieldName:
		return m.Name()
	case applyrecord.FieldLevel:
		return m.Level()
	case applyrecord.FieldAvatar:
		return m.Avatar()
	case applyrecord.FieldCreateAt:
		return m.CreateAt()
	case applyrecord.FieldUpdateAt:
		return m.UpdateAt()
	case applyrecord.FieldIsPassed:
		return m.IsPassed()
	case applyrecord.FieldMessages:
		return m.Messages()
	case applyrecord.FieldAuditorID:
		return m.AuditorID()
	case applyrecord.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplyRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case applyrecord.FieldDetail:
		return m.OldDetail(ctx)
	case applyrecord.FieldCurriculumVitae:
		return m.OldCurriculumVitae(ctx)
	case applyrecord.FieldWorks:
		return m.OldWorks(ctx)
	case applyrecord.FieldSkills:
		return m.OldSkills(ctx)
	case applyrecord.FieldName:
		return m.OldName(ctx)
	case applyrecord.FieldLevel:
		return m.OldLevel(ctx)
	case applyrecord.FieldAvatar:
		return m.OldAvatar(ctx)
	case applyrecord.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case applyrecord.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case applyrecord.FieldIsPassed:
		return m.OldIsPassed(ctx)
	case applyrecord.FieldMessages:
		return m.OldMessages(ctx)
	case applyrecord.FieldAuditorID:
		return m.OldAuditorID(ctx)
	case applyrecord.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown ApplyRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplyRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case applyrecord.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case applyrecord.FieldCurriculumVitae:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurriculumVitae(v)
		return nil
	case applyrecord.FieldWorks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorks(v)
		return nil
	case applyrecord.FieldSkills:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case applyrecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case applyrecord.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case applyrecord.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case applyrecord.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case applyrecord.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case applyrecord.FieldIsPassed:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPassed(v)
		return nil
	case applyrecord.FieldMessages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case applyrecord.FieldAuditorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorID(v)
		return nil
	case applyrecord.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown ApplyRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplyRecordMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, applyrecord.FieldLevel)
	}
	if m.addis_passed != nil {
		fields = append(fields, applyrecord.FieldIsPassed)
	}
	if m.addauditor_id != nil {
		fields = append(fields, applyrecord.FieldAuditorID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplyRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case applyrecord.FieldLevel:
		return m.AddedLevel()
	case applyrecord.FieldIsPassed:
		return m.AddedIsPassed()
	case applyrecord.FieldAuditorID:
		return m.AddedAuditorID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplyRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case applyrecord.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case applyrecord.FieldIsPassed:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsPassed(v)
		return nil
	case applyrecord.FieldAuditorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuditorID(v)
		return nil
	}
	return fmt.Errorf("unknown ApplyRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplyRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(applyrecord.FieldDetail) {
		fields = append(fields, applyrecord.FieldDetail)
	}
	if m.FieldCleared(applyrecord.FieldCurriculumVitae) {
		fields = append(fields, applyrecord.FieldCurriculumVitae)
	}
	if m.FieldCleared(applyrecord.FieldWorks) {
		fields = append(fields, applyrecord.FieldWorks)
	}
	if m.FieldCleared(applyrecord.FieldSkills) {
		fields = append(fields, applyrecord.FieldSkills)
	}
	if m.FieldCleared(applyrecord.FieldAvatar) {
		fields = append(fields, applyrecord.FieldAvatar)
	}
	if m.FieldCleared(applyrecord.FieldMessages) {
		fields = append(fields, applyrecord.FieldMessages)
	}
	if m.FieldCleared(applyrecord.FieldAuditorID) {
		fields = append(fields, applyrecord.FieldAuditorID)
	}
	if m.FieldCleared(applyrecord.FieldUserID) {
		fields = append(fields, applyrecord.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplyRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplyRecordMutation) ClearField(name string) error {
	switch name {
	case applyrecord.FieldDetail:
		m.ClearDetail()
		return nil
	case applyrecord.FieldCurriculumVitae:
		m.ClearCurriculumVitae()
		return nil
	case applyrecord.FieldWorks:
		m.ClearWorks()
		return nil
	case applyrecord.FieldSkills:
		m.ClearSkills()
		return nil
	case applyrecord.FieldAvatar:
		m.ClearAvatar()
		return nil
	case applyrecord.FieldMessages:
		m.ClearMessages()
		return nil
	case applyrecord.FieldAuditorID:
		m.ClearAuditorID()
		return nil
	case applyrecord.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown ApplyRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplyRecordMutation) ResetField(name string) error {
	switch name {
	case applyrecord.FieldDetail:
		m.ResetDetail()
		return nil
	case applyrecord.FieldCurriculumVitae:
		m.ResetCurriculumVitae()
		return nil
	case applyrecord.FieldWorks:
		m.ResetWorks()
		return nil
	case applyrecord.FieldSkills:
		m.ResetSkills()
		return nil
	case applyrecord.FieldName:
		m.ResetName()
		return nil
	case applyrecord.FieldLevel:
		m.ResetLevel()
		return nil
	case applyrecord.FieldAvatar:
		m.ResetAvatar()
		return nil
	case applyrecord.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case applyrecord.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case applyrecord.FieldIsPassed:
		m.ResetIsPassed()
		return nil
	case applyrecord.FieldMessages:
		m.ResetMessages()
		return nil
	case applyrecord.FieldAuditorID:
		m.ResetAuditorID()
		return nil
	case applyrecord.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown ApplyRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplyRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, applyrecord.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplyRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case applyrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplyRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplyRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplyRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, applyrecord.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplyRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case applyrecord.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplyRecordMutation) ClearEdge(name string) error {
	switch name {
	case applyrecord.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ApplyRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplyRecordMutation) ResetEdge(name string) error {
	switch name {
	case applyrecord.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ApplyRecord edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	level           *int
	addlevel        *int
	clearedFields   map[string]struct{}
	courses         map[int]struct{}
	removedcourses  map[int]struct{}
	clearedcourses  bool
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*Category, error)
	predicates      []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *CategoryMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CategoryMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *CategoryMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CategoryMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *CategoryMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetParentID sets the "parent_id" field.
func (m *CategoryMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CategoryMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CategoryMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[category.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CategoryMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, category.FieldParentID)
}

// AddCourseIDs adds the "courses" edge to the Course entity by ids.
func (m *CategoryMutation) AddCourseIDs(ids ...int) {
	if m.courses == nil {
		m.courses = make(map[int]struct{})
	}
	for i := range ids {
		m.courses[ids[i]] = struct{}{}
	}
}

// ClearCourses clears the "courses" edge to the Course entity.
func (m *CategoryMutation) ClearCourses() {
	m.clearedcourses = true
}

// CoursesCleared reports if the "courses" edge to the Course entity was cleared.
func (m *CategoryMutation) CoursesCleared() bool {
	return m.clearedcourses
}

// RemoveCourseIDs removes the "courses" edge to the Course entity by IDs.
func (m *CategoryMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourses == nil {
		m.removedcourses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.courses, ids[i])
		m.removedcourses[ids[i]] = struct{}{}
	}
}

// RemovedCourses returns the removed IDs of the "courses" edge to the Course entity.
func (m *CategoryMutation) RemovedCoursesIDs() (ids []int) {
	for id := range m.removedcourses {
		ids = append(ids, id)
	}
	return
}

// CoursesIDs returns the "courses" edge IDs in the mutation.
func (m *CategoryMutation) CoursesIDs() (ids []int) {
	for id := range m.courses {
		ids = append(ids, id)
	}
	return
}

// ResetCourses resets all changes to the "courses" edge.
func (m *CategoryMutation) ResetCourses() {
	m.courses = nil
	m.clearedcourses = false
	m.removedcourses = nil
}

// ClearParent clears the "parent" edge to the Category entity.
func (m *CategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Category entity was cleared.
func (m *CategoryMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Category entity by ids.
func (m *CategoryMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Category entity.
func (m *CategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Category entity was cleared.
func (m *CategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Category entity by IDs.
func (m *CategoryMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Category entity.
func (m *CategoryMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CategoryMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.level != nil {
		fields = append(fields, category.FieldLevel)
	}
	if m.parent != nil {
		fields = append(fields, category.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldLevel:
		return m.Level()
	case category.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldLevel:
		return m.OldLevel(ctx)
	case category.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, category.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldParentID) {
		fields = append(fields, category.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldLevel:
		m.ResetLevel()
		return nil
	case category.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.courses != nil {
		edges = append(edges, category.EdgeCourses)
	}
	if m.parent != nil {
		edges = append(edges, category.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.courses))
		for id := range m.courses {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcourses != nil {
		edges = append(edges, category.EdgeCourses)
	}
	if m.removedchildren != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.removedcourses))
		for id := range m.removedcourses {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcourses {
		edges = append(edges, category.EdgeCourses)
	}
	if m.clearedparent {
		edges = append(edges, category.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeCourses:
		return m.clearedcourses
	case category.EdgeParent:
		return m.clearedparent
	case category.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeCourses:
		m.ResetCourses()
		return nil
	case category.EdgeParent:
		m.ResetParent()
		return nil
	case category.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// ChapterMutation represents an operation that mutates the Chapter nodes in the graph.
type ChapterMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	released_time  *time.Time
	description    *string
	sort           *int
	addsort        *int
	clearedFields  map[string]struct{}
	lessons        map[int]struct{}
	removedlessons map[int]struct{}
	clearedlessons bool
	course         *int
	clearedcourse  bool
	done           bool
	oldValue       func(context.Context) (*Chapter, error)
	predicates     []predicate.Chapter
}

var _ ent.Mutation = (*ChapterMutation)(nil)

// chapterOption allows management of the mutation configuration using functional options.
type chapterOption func(*ChapterMutation)

// newChapterMutation creates new mutation for the Chapter entity.
func newChapterMutation(c config, op Op, opts ...chapterOption) *ChapterMutation {
	m := &ChapterMutation{
		config:        c,
		op:            op,
		typ:           TypeChapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChapterID sets the ID field of the mutation.
func withChapterID(id int) chapterOption {
	return func(m *ChapterMutation) {
		var (
			err   error
			once  sync.Once
			value *Chapter
		)
		m.oldValue = func(ctx context.Context) (*Chapter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChapter sets the old Chapter of the mutation.
func withChapter(node *Chapter) chapterOption {
	return func(m *ChapterMutation) {
		m.oldValue = func(context.Context) (*Chapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChapterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChapterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chapter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ChapterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChapterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChapterMutation) ResetName() {
	m.name = nil
}

// SetReleasedTime sets the "released_time" field.
func (m *ChapterMutation) SetReleasedTime(t time.Time) {
	m.released_time = &t
}

// ReleasedTime returns the value of the "released_time" field in the mutation.
func (m *ChapterMutation) ReleasedTime() (r time.Time, exists bool) {
	v := m.released_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReleasedTime returns the old "released_time" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldReleasedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleasedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleasedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleasedTime: %w", err)
	}
	return oldValue.ReleasedTime, nil
}

// ResetReleasedTime resets all changes to the "released_time" field.
func (m *ChapterMutation) ResetReleasedTime() {
	m.released_time = nil
}

// SetDescription sets the "description" field.
func (m *ChapterMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChapterMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ChapterMutation) ResetDescription() {
	m.description = nil
}

// SetSort sets the "sort" field.
func (m *ChapterMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ChapterMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *ChapterMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ChapterMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ChapterMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetCourseID sets the "course_id" field.
func (m *ChapterMutation) SetCourseID(i int) {
	m.course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *ChapterMutation) CourseID() (r int, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ClearCourseID clears the value of the "course_id" field.
func (m *ChapterMutation) ClearCourseID() {
	m.course = nil
	m.clearedFields[chapter.FieldCourseID] = struct{}{}
}

// CourseIDCleared returns if the "course_id" field was cleared in this mutation.
func (m *ChapterMutation) CourseIDCleared() bool {
	_, ok := m.clearedFields[chapter.FieldCourseID]
	return ok
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *ChapterMutation) ResetCourseID() {
	m.course = nil
	delete(m.clearedFields, chapter.FieldCourseID)
}

// AddLessonIDs adds the "lessons" edge to the Lesson entity by ids.
func (m *ChapterMutation) AddLessonIDs(ids ...int) {
	if m.lessons == nil {
		m.lessons = make(map[int]struct{})
	}
	for i := range ids {
		m.lessons[ids[i]] = struct{}{}
	}
}

// ClearLessons clears the "lessons" edge to the Lesson entity.
func (m *ChapterMutation) ClearLessons() {
	m.clearedlessons = true
}

// LessonsCleared reports if the "lessons" edge to the Lesson entity was cleared.
func (m *ChapterMutation) LessonsCleared() bool {
	return m.clearedlessons
}

// RemoveLessonIDs removes the "lessons" edge to the Lesson entity by IDs.
func (m *ChapterMutation) RemoveLessonIDs(ids ...int) {
	if m.removedlessons == nil {
		m.removedlessons = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lessons, ids[i])
		m.removedlessons[ids[i]] = struct{}{}
	}
}

// RemovedLessons returns the removed IDs of the "lessons" edge to the Lesson entity.
func (m *ChapterMutation) RemovedLessonsIDs() (ids []int) {
	for id := range m.removedlessons {
		ids = append(ids, id)
	}
	return
}

// LessonsIDs returns the "lessons" edge IDs in the mutation.
func (m *ChapterMutation) LessonsIDs() (ids []int) {
	for id := range m.lessons {
		ids = append(ids, id)
	}
	return
}

// ResetLessons resets all changes to the "lessons" edge.
func (m *ChapterMutation) ResetLessons() {
	m.lessons = nil
	m.clearedlessons = false
	m.removedlessons = nil
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *ChapterMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *ChapterMutation) CourseCleared() bool {
	return m.CourseIDCleared() || m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *ChapterMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *ChapterMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// Where appends a list predicates to the ChapterMutation builder.
func (m *ChapterMutation) Where(ps ...predicate.Chapter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChapterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChapterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chapter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChapterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChapterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chapter).
func (m *ChapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChapterMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, chapter.FieldName)
	}
	if m.released_time != nil {
		fields = append(fields, chapter.FieldReleasedTime)
	}
	if m.description != nil {
		fields = append(fields, chapter.FieldDescription)
	}
	if m.sort != nil {
		fields = append(fields, chapter.FieldSort)
	}
	if m.course != nil {
		fields = append(fields, chapter.FieldCourseID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chapter.FieldName:
		return m.Name()
	case chapter.FieldReleasedTime:
		return m.ReleasedTime()
	case chapter.FieldDescription:
		return m.Description()
	case chapter.FieldSort:
		return m.Sort()
	case chapter.FieldCourseID:
		return m.CourseID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chapter.FieldName:
		return m.OldName(ctx)
	case chapter.FieldReleasedTime:
		return m.OldReleasedTime(ctx)
	case chapter.FieldDescription:
		return m.OldDescription(ctx)
	case chapter.FieldSort:
		return m.OldSort(ctx)
	case chapter.FieldCourseID:
		return m.OldCourseID(ctx)
	}
	return nil, fmt.Errorf("unknown Chapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chapter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case chapter.FieldReleasedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleasedTime(v)
		return nil
	case chapter.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case chapter.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case chapter.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	}
	return fmt.Errorf("unknown Chapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChapterMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, chapter.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChapterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chapter.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chapter.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Chapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChapterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chapter.FieldCourseID) {
		fields = append(fields, chapter.FieldCourseID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChapterMutation) ClearField(name string) error {
	switch name {
	case chapter.FieldCourseID:
		m.ClearCourseID()
		return nil
	}
	return fmt.Errorf("unknown Chapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChapterMutation) ResetField(name string) error {
	switch name {
	case chapter.FieldName:
		m.ResetName()
		return nil
	case chapter.FieldReleasedTime:
		m.ResetReleasedTime()
		return nil
	case chapter.FieldDescription:
		m.ResetDescription()
		return nil
	case chapter.FieldSort:
		m.ResetSort()
		return nil
	case chapter.FieldCourseID:
		m.ResetCourseID()
		return nil
	}
	return fmt.Errorf("unknown Chapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.lessons != nil {
		edges = append(edges, chapter.EdgeLessons)
	}
	if m.course != nil {
		edges = append(edges, chapter.EdgeCourse)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chapter.EdgeLessons:
		ids := make([]ent.Value, 0, len(m.lessons))
		for id := range m.lessons {
			ids = append(ids, id)
		}
		return ids
	case chapter.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedlessons != nil {
		edges = append(edges, chapter.EdgeLessons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChapterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case chapter.EdgeLessons:
		ids := make([]ent.Value, 0, len(m.removedlessons))
		for id := range m.removedlessons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlessons {
		edges = append(edges, chapter.EdgeLessons)
	}
	if m.clearedcourse {
		edges = append(edges, chapter.EdgeCourse)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChapterMutation) EdgeCleared(name string) bool {
	switch name {
	case chapter.EdgeLessons:
		return m.clearedlessons
	case chapter.EdgeCourse:
		return m.clearedcourse
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChapterMutation) ClearEdge(name string) error {
	switch name {
	case chapter.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown Chapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChapterMutation) ResetEdge(name string) error {
	switch name {
	case chapter.EdgeLessons:
		m.ResetLessons()
		return nil
	case chapter.EdgeCourse:
		m.ResetCourse()
		return nil
	}
	return fmt.Errorf("unknown Chapter edge %s", name)
}

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op              Op
	typ             string
	id              *int
	level           *int32
	addlevel        *int32
	updated_at      *time.Time
	name            *string
	detail          *string
	cover           *string
	price           *int32
	addprice        *int32
	tags            *string
	created_at      *time.Time
	status          *int32
	addstatus       *int32
	score           *int32
	addscore        *int32
	duration        *int32
	addduration     *int32
	people          *int32
	addpeople       *int32
	clearedFields   map[string]struct{}
	owner           *int
	clearedowner    bool
	chapters        map[int]struct{}
	removedchapters map[int]struct{}
	clearedchapters bool
	teacher         *int
	clearedteacher  bool
	done            bool
	oldValue        func(context.Context) (*Course, error)
	predicates      []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLevel sets the "level" field.
func (m *CourseMutation) SetLevel(i int32) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CourseMutation) Level() (r int32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *CourseMutation) AddLevel(i int32) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CourseMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *CourseMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CourseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CourseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CourseMutation) ResetName() {
	m.name = nil
}

// SetDetail sets the "detail" field.
func (m *CourseMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *CourseMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *CourseMutation) ResetDetail() {
	m.detail = nil
}

// SetCover sets the "cover" field.
func (m *CourseMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *CourseMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ResetCover resets all changes to the "cover" field.
func (m *CourseMutation) ResetCover() {
	m.cover = nil
}

// SetPrice sets the "price" field.
func (m *CourseMutation) SetPrice(i int32) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *CourseMutation) Price() (r int32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *CourseMutation) AddPrice(i int32) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *CourseMutation) AddedPrice() (r int32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *CourseMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetTags sets the "tags" field.
func (m *CourseMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CourseMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *CourseMutation) ResetTags() {
	m.tags = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStatus sets the "status" field.
func (m *CourseMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CourseMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CourseMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CourseMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CourseMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCategoryID sets the "category_id" field.
func (m *CourseMutation) SetCategoryID(i int) {
	m.owner = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *CourseMutation) CategoryID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *CourseMutation) ClearCategoryID() {
	m.owner = nil
	m.clearedFields[course.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *CourseMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[course.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *CourseMutation) ResetCategoryID() {
	m.owner = nil
	delete(m.clearedFields, course.FieldCategoryID)
}

// SetScore sets the "score" field.
func (m *CourseMutation) SetScore(i int32) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *CourseMutation) Score() (r int32, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldScore(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *CourseMutation) AddScore(i int32) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *CourseMutation) AddedScore() (r int32, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *CourseMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetDuration sets the "duration" field.
func (m *CourseMutation) SetDuration(i int32) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *CourseMutation) Duration() (r int32, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDuration(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *CourseMutation) AddDuration(i int32) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *CourseMutation) AddedDuration() (r int32, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *CourseMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetPeople sets the "people" field.
func (m *CourseMutation) SetPeople(i int32) {
	m.people = &i
	m.addpeople = nil
}

// People returns the value of the "people" field in the mutation.
func (m *CourseMutation) People() (r int32, exists bool) {
	v := m.people
	if v == nil {
		return
	}
	return *v, true
}

// OldPeople returns the old "people" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldPeople(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeople is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeople requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeople: %w", err)
	}
	return oldValue.People, nil
}

// AddPeople adds i to the "people" field.
func (m *CourseMutation) AddPeople(i int32) {
	if m.addpeople != nil {
		*m.addpeople += i
	} else {
		m.addpeople = &i
	}
}

// AddedPeople returns the value that was added to the "people" field in this mutation.
func (m *CourseMutation) AddedPeople() (r int32, exists bool) {
	v := m.addpeople
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeople resets all changes to the "people" field.
func (m *CourseMutation) ResetPeople() {
	m.people = nil
	m.addpeople = nil
}

// SetTeacherID sets the "teacher_id" field.
func (m *CourseMutation) SetTeacherID(i int) {
	m.teacher = &i
}

// TeacherID returns the value of the "teacher_id" field in the mutation.
func (m *CourseMutation) TeacherID() (r int, exists bool) {
	v := m.teacher
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherID returns the old "teacher_id" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTeacherID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeacherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeacherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherID: %w", err)
	}
	return oldValue.TeacherID, nil
}

// ClearTeacherID clears the value of the "teacher_id" field.
func (m *CourseMutation) ClearTeacherID() {
	m.teacher = nil
	m.clearedFields[course.FieldTeacherID] = struct{}{}
}

// TeacherIDCleared returns if the "teacher_id" field was cleared in this mutation.
func (m *CourseMutation) TeacherIDCleared() bool {
	_, ok := m.clearedFields[course.FieldTeacherID]
	return ok
}

// ResetTeacherID resets all changes to the "teacher_id" field.
func (m *CourseMutation) ResetTeacherID() {
	m.teacher = nil
	delete(m.clearedFields, course.FieldTeacherID)
}

// SetOwnerID sets the "owner" edge to the Category entity by id.
func (m *CourseMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Category entity.
func (m *CourseMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Category entity was cleared.
func (m *CourseMutation) OwnerCleared() bool {
	return m.CategoryIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CourseMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CourseMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddChapterIDs adds the "chapters" edge to the Chapter entity by ids.
func (m *CourseMutation) AddChapterIDs(ids ...int) {
	if m.chapters == nil {
		m.chapters = make(map[int]struct{})
	}
	for i := range ids {
		m.chapters[ids[i]] = struct{}{}
	}
}

// ClearChapters clears the "chapters" edge to the Chapter entity.
func (m *CourseMutation) ClearChapters() {
	m.clearedchapters = true
}

// ChaptersCleared reports if the "chapters" edge to the Chapter entity was cleared.
func (m *CourseMutation) ChaptersCleared() bool {
	return m.clearedchapters
}

// RemoveChapterIDs removes the "chapters" edge to the Chapter entity by IDs.
func (m *CourseMutation) RemoveChapterIDs(ids ...int) {
	if m.removedchapters == nil {
		m.removedchapters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.chapters, ids[i])
		m.removedchapters[ids[i]] = struct{}{}
	}
}

// RemovedChapters returns the removed IDs of the "chapters" edge to the Chapter entity.
func (m *CourseMutation) RemovedChaptersIDs() (ids []int) {
	for id := range m.removedchapters {
		ids = append(ids, id)
	}
	return
}

// ChaptersIDs returns the "chapters" edge IDs in the mutation.
func (m *CourseMutation) ChaptersIDs() (ids []int) {
	for id := range m.chapters {
		ids = append(ids, id)
	}
	return
}

// ResetChapters resets all changes to the "chapters" edge.
func (m *CourseMutation) ResetChapters() {
	m.chapters = nil
	m.clearedchapters = false
	m.removedchapters = nil
}

// ClearTeacher clears the "teacher" edge to the Teacher entity.
func (m *CourseMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the Teacher entity was cleared.
func (m *CourseMutation) TeacherCleared() bool {
	return m.TeacherIDCleared() || m.clearedteacher
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) TeacherIDs() (ids []int) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *CourseMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Course, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.level != nil {
		fields = append(fields, course.FieldLevel)
	}
	if m.updated_at != nil {
		fields = append(fields, course.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, course.FieldName)
	}
	if m.detail != nil {
		fields = append(fields, course.FieldDetail)
	}
	if m.cover != nil {
		fields = append(fields, course.FieldCover)
	}
	if m.price != nil {
		fields = append(fields, course.FieldPrice)
	}
	if m.tags != nil {
		fields = append(fields, course.FieldTags)
	}
	if m.created_at != nil {
		fields = append(fields, course.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, course.FieldStatus)
	}
	if m.owner != nil {
		fields = append(fields, course.FieldCategoryID)
	}
	if m.score != nil {
		fields = append(fields, course.FieldScore)
	}
	if m.duration != nil {
		fields = append(fields, course.FieldDuration)
	}
	if m.people != nil {
		fields = append(fields, course.FieldPeople)
	}
	if m.teacher != nil {
		fields = append(fields, course.FieldTeacherID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldLevel:
		return m.Level()
	case course.FieldUpdatedAt:
		return m.UpdatedAt()
	case course.FieldName:
		return m.Name()
	case course.FieldDetail:
		return m.Detail()
	case course.FieldCover:
		return m.Cover()
	case course.FieldPrice:
		return m.Price()
	case course.FieldTags:
		return m.Tags()
	case course.FieldCreatedAt:
		return m.CreatedAt()
	case course.FieldStatus:
		return m.Status()
	case course.FieldCategoryID:
		return m.CategoryID()
	case course.FieldScore:
		return m.Score()
	case course.FieldDuration:
		return m.Duration()
	case course.FieldPeople:
		return m.People()
	case course.FieldTeacherID:
		return m.TeacherID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldLevel:
		return m.OldLevel(ctx)
	case course.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case course.FieldName:
		return m.OldName(ctx)
	case course.FieldDetail:
		return m.OldDetail(ctx)
	case course.FieldCover:
		return m.OldCover(ctx)
	case course.FieldPrice:
		return m.OldPrice(ctx)
	case course.FieldTags:
		return m.OldTags(ctx)
	case course.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case course.FieldStatus:
		return m.OldStatus(ctx)
	case course.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case course.FieldScore:
		return m.OldScore(ctx)
	case course.FieldDuration:
		return m.OldDuration(ctx)
	case course.FieldPeople:
		return m.OldPeople(ctx)
	case course.FieldTeacherID:
		return m.OldTeacherID(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case course.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case course.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case course.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case course.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	case course.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case course.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case course.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case course.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case course.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case course.FieldScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case course.FieldDuration:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case course.FieldPeople:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeople(v)
		return nil
	case course.FieldTeacherID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherID(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, course.FieldLevel)
	}
	if m.addprice != nil {
		fields = append(fields, course.FieldPrice)
	}
	if m.addstatus != nil {
		fields = append(fields, course.FieldStatus)
	}
	if m.addscore != nil {
		fields = append(fields, course.FieldScore)
	}
	if m.addduration != nil {
		fields = append(fields, course.FieldDuration)
	}
	if m.addpeople != nil {
		fields = append(fields, course.FieldPeople)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case course.FieldLevel:
		return m.AddedLevel()
	case course.FieldPrice:
		return m.AddedPrice()
	case course.FieldStatus:
		return m.AddedStatus()
	case course.FieldScore:
		return m.AddedScore()
	case course.FieldDuration:
		return m.AddedDuration()
	case course.FieldPeople:
		return m.AddedPeople()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case course.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case course.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case course.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case course.FieldScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case course.FieldDuration:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case course.FieldPeople:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeople(v)
		return nil
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(course.FieldCategoryID) {
		fields = append(fields, course.FieldCategoryID)
	}
	if m.FieldCleared(course.FieldTeacherID) {
		fields = append(fields, course.FieldTeacherID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	switch name {
	case course.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case course.FieldTeacherID:
		m.ClearTeacherID()
		return nil
	}
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldLevel:
		m.ResetLevel()
		return nil
	case course.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case course.FieldName:
		m.ResetName()
		return nil
	case course.FieldDetail:
		m.ResetDetail()
		return nil
	case course.FieldCover:
		m.ResetCover()
		return nil
	case course.FieldPrice:
		m.ResetPrice()
		return nil
	case course.FieldTags:
		m.ResetTags()
		return nil
	case course.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case course.FieldStatus:
		m.ResetStatus()
		return nil
	case course.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case course.FieldScore:
		m.ResetScore()
		return nil
	case course.FieldDuration:
		m.ResetDuration()
		return nil
	case course.FieldPeople:
		m.ResetPeople()
		return nil
	case course.FieldTeacherID:
		m.ResetTeacherID()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, course.EdgeOwner)
	}
	if m.chapters != nil {
		edges = append(edges, course.EdgeChapters)
	}
	if m.teacher != nil {
		edges = append(edges, course.EdgeTeacher)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.chapters))
		for id := range m.chapters {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchapters != nil {
		edges = append(edges, course.EdgeChapters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.removedchapters))
		for id := range m.removedchapters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, course.EdgeOwner)
	}
	if m.clearedchapters {
		edges = append(edges, course.EdgeChapters)
	}
	if m.clearedteacher {
		edges = append(edges, course.EdgeTeacher)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeOwner:
		return m.clearedowner
	case course.EdgeChapters:
		return m.clearedchapters
	case course.EdgeTeacher:
		return m.clearedteacher
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeOwner:
		m.ClearOwner()
		return nil
	case course.EdgeTeacher:
		m.ClearTeacher()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeOwner:
		m.ResetOwner()
		return nil
	case course.EdgeChapters:
		m.ResetChapters()
		return nil
	case course.EdgeTeacher:
		m.ResetTeacher()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// LessonMutation represents an operation that mutates the Lesson nodes in the graph.
type LessonMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	released_time      *time.Time
	sort               *int
	addsort            *int
	_type              *int
	add_type           *int
	storage_path       *string
	source             *string
	courseware         *string
	is_free_preview    *int
	addis_free_preview *int
	clearedFields      map[string]struct{}
	chapter            *int
	clearedchapter     bool
	done               bool
	oldValue           func(context.Context) (*Lesson, error)
	predicates         []predicate.Lesson
}

var _ ent.Mutation = (*LessonMutation)(nil)

// lessonOption allows management of the mutation configuration using functional options.
type lessonOption func(*LessonMutation)

// newLessonMutation creates new mutation for the Lesson entity.
func newLessonMutation(c config, op Op, opts ...lessonOption) *LessonMutation {
	m := &LessonMutation{
		config:        c,
		op:            op,
		typ:           TypeLesson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLessonID sets the ID field of the mutation.
func withLessonID(id int) lessonOption {
	return func(m *LessonMutation) {
		var (
			err   error
			once  sync.Once
			value *Lesson
		)
		m.oldValue = func(ctx context.Context) (*Lesson, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lesson.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLesson sets the old Lesson of the mutation.
func withLesson(node *Lesson) lessonOption {
	return func(m *LessonMutation) {
		m.oldValue = func(context.Context) (*Lesson, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LessonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LessonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LessonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LessonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lesson.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LessonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LessonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LessonMutation) ResetName() {
	m.name = nil
}

// SetReleasedTime sets the "released_time" field.
func (m *LessonMutation) SetReleasedTime(t time.Time) {
	m.released_time = &t
}

// ReleasedTime returns the value of the "released_time" field in the mutation.
func (m *LessonMutation) ReleasedTime() (r time.Time, exists bool) {
	v := m.released_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReleasedTime returns the old "released_time" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldReleasedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleasedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleasedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleasedTime: %w", err)
	}
	return oldValue.ReleasedTime, nil
}

// ResetReleasedTime resets all changes to the "released_time" field.
func (m *LessonMutation) ResetReleasedTime() {
	m.released_time = nil
}

// SetSort sets the "sort" field.
func (m *LessonMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *LessonMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *LessonMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *LessonMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *LessonMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetType sets the "type" field.
func (m *LessonMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *LessonMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *LessonMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *LessonMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *LessonMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetStoragePath sets the "storage_path" field.
func (m *LessonMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *LessonMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *LessonMutation) ResetStoragePath() {
	m.storage_path = nil
}

// SetSource sets the "source" field.
func (m *LessonMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *LessonMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *LessonMutation) ResetSource() {
	m.source = nil
}

// SetCourseware sets the "courseware" field.
func (m *LessonMutation) SetCourseware(s string) {
	m.courseware = &s
}

// Courseware returns the value of the "courseware" field in the mutation.
func (m *LessonMutation) Courseware() (r string, exists bool) {
	v := m.courseware
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseware returns the old "courseware" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldCourseware(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseware is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseware requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseware: %w", err)
	}
	return oldValue.Courseware, nil
}

// ResetCourseware resets all changes to the "courseware" field.
func (m *LessonMutation) ResetCourseware() {
	m.courseware = nil
}

// SetIsFreePreview sets the "is_free_preview" field.
func (m *LessonMutation) SetIsFreePreview(i int) {
	m.is_free_preview = &i
	m.addis_free_preview = nil
}

// IsFreePreview returns the value of the "is_free_preview" field in the mutation.
func (m *LessonMutation) IsFreePreview() (r int, exists bool) {
	v := m.is_free_preview
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFreePreview returns the old "is_free_preview" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldIsFreePreview(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFreePreview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFreePreview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFreePreview: %w", err)
	}
	return oldValue.IsFreePreview, nil
}

// AddIsFreePreview adds i to the "is_free_preview" field.
func (m *LessonMutation) AddIsFreePreview(i int) {
	if m.addis_free_preview != nil {
		*m.addis_free_preview += i
	} else {
		m.addis_free_preview = &i
	}
}

// AddedIsFreePreview returns the value that was added to the "is_free_preview" field in this mutation.
func (m *LessonMutation) AddedIsFreePreview() (r int, exists bool) {
	v := m.addis_free_preview
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsFreePreview resets all changes to the "is_free_preview" field.
func (m *LessonMutation) ResetIsFreePreview() {
	m.is_free_preview = nil
	m.addis_free_preview = nil
}

// SetChapterID sets the "chapter_id" field.
func (m *LessonMutation) SetChapterID(i int) {
	m.chapter = &i
}

// ChapterID returns the value of the "chapter_id" field in the mutation.
func (m *LessonMutation) ChapterID() (r int, exists bool) {
	v := m.chapter
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterID returns the old "chapter_id" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldChapterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterID: %w", err)
	}
	return oldValue.ChapterID, nil
}

// ClearChapterID clears the value of the "chapter_id" field.
func (m *LessonMutation) ClearChapterID() {
	m.chapter = nil
	m.clearedFields[lesson.FieldChapterID] = struct{}{}
}

// ChapterIDCleared returns if the "chapter_id" field was cleared in this mutation.
func (m *LessonMutation) ChapterIDCleared() bool {
	_, ok := m.clearedFields[lesson.FieldChapterID]
	return ok
}

// ResetChapterID resets all changes to the "chapter_id" field.
func (m *LessonMutation) ResetChapterID() {
	m.chapter = nil
	delete(m.clearedFields, lesson.FieldChapterID)
}

// ClearChapter clears the "chapter" edge to the Chapter entity.
func (m *LessonMutation) ClearChapter() {
	m.clearedchapter = true
}

// ChapterCleared reports if the "chapter" edge to the Chapter entity was cleared.
func (m *LessonMutation) ChapterCleared() bool {
	return m.ChapterIDCleared() || m.clearedchapter
}

// ChapterIDs returns the "chapter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChapterID instead. It exists only for internal usage by the builders.
func (m *LessonMutation) ChapterIDs() (ids []int) {
	if id := m.chapter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChapter resets all changes to the "chapter" edge.
func (m *LessonMutation) ResetChapter() {
	m.chapter = nil
	m.clearedchapter = false
}

// Where appends a list predicates to the LessonMutation builder.
func (m *LessonMutation) Where(ps ...predicate.Lesson) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LessonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LessonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lesson, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LessonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LessonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lesson).
func (m *LessonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LessonMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, lesson.FieldName)
	}
	if m.released_time != nil {
		fields = append(fields, lesson.FieldReleasedTime)
	}
	if m.sort != nil {
		fields = append(fields, lesson.FieldSort)
	}
	if m._type != nil {
		fields = append(fields, lesson.FieldType)
	}
	if m.storage_path != nil {
		fields = append(fields, lesson.FieldStoragePath)
	}
	if m.source != nil {
		fields = append(fields, lesson.FieldSource)
	}
	if m.courseware != nil {
		fields = append(fields, lesson.FieldCourseware)
	}
	if m.is_free_preview != nil {
		fields = append(fields, lesson.FieldIsFreePreview)
	}
	if m.chapter != nil {
		fields = append(fields, lesson.FieldChapterID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LessonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lesson.FieldName:
		return m.Name()
	case lesson.FieldReleasedTime:
		return m.ReleasedTime()
	case lesson.FieldSort:
		return m.Sort()
	case lesson.FieldType:
		return m.GetType()
	case lesson.FieldStoragePath:
		return m.StoragePath()
	case lesson.FieldSource:
		return m.Source()
	case lesson.FieldCourseware:
		return m.Courseware()
	case lesson.FieldIsFreePreview:
		return m.IsFreePreview()
	case lesson.FieldChapterID:
		return m.ChapterID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LessonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lesson.FieldName:
		return m.OldName(ctx)
	case lesson.FieldReleasedTime:
		return m.OldReleasedTime(ctx)
	case lesson.FieldSort:
		return m.OldSort(ctx)
	case lesson.FieldType:
		return m.OldType(ctx)
	case lesson.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case lesson.FieldSource:
		return m.OldSource(ctx)
	case lesson.FieldCourseware:
		return m.OldCourseware(ctx)
	case lesson.FieldIsFreePreview:
		return m.OldIsFreePreview(ctx)
	case lesson.FieldChapterID:
		return m.OldChapterID(ctx)
	}
	return nil, fmt.Errorf("unknown Lesson field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lesson.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case lesson.FieldReleasedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleasedTime(v)
		return nil
	case lesson.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case lesson.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case lesson.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case lesson.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case lesson.FieldCourseware:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseware(v)
		return nil
	case lesson.FieldIsFreePreview:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFreePreview(v)
		return nil
	case lesson.FieldChapterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterID(v)
		return nil
	}
	return fmt.Errorf("unknown Lesson field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LessonMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, lesson.FieldSort)
	}
	if m.add_type != nil {
		fields = append(fields, lesson.FieldType)
	}
	if m.addis_free_preview != nil {
		fields = append(fields, lesson.FieldIsFreePreview)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LessonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lesson.FieldSort:
		return m.AddedSort()
	case lesson.FieldType:
		return m.AddedType()
	case lesson.FieldIsFreePreview:
		return m.AddedIsFreePreview()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lesson.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case lesson.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case lesson.FieldIsFreePreview:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFreePreview(v)
		return nil
	}
	return fmt.Errorf("unknown Lesson numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LessonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lesson.FieldChapterID) {
		fields = append(fields, lesson.FieldChapterID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LessonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LessonMutation) ClearField(name string) error {
	switch name {
	case lesson.FieldChapterID:
		m.ClearChapterID()
		return nil
	}
	return fmt.Errorf("unknown Lesson nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LessonMutation) ResetField(name string) error {
	switch name {
	case lesson.FieldName:
		m.ResetName()
		return nil
	case lesson.FieldReleasedTime:
		m.ResetReleasedTime()
		return nil
	case lesson.FieldSort:
		m.ResetSort()
		return nil
	case lesson.FieldType:
		m.ResetType()
		return nil
	case lesson.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case lesson.FieldSource:
		m.ResetSource()
		return nil
	case lesson.FieldCourseware:
		m.ResetCourseware()
		return nil
	case lesson.FieldIsFreePreview:
		m.ResetIsFreePreview()
		return nil
	case lesson.FieldChapterID:
		m.ResetChapterID()
		return nil
	}
	return fmt.Errorf("unknown Lesson field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LessonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.chapter != nil {
		edges = append(edges, lesson.EdgeChapter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LessonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lesson.EdgeChapter:
		if id := m.chapter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LessonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LessonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LessonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchapter {
		edges = append(edges, lesson.EdgeChapter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LessonMutation) EdgeCleared(name string) bool {
	switch name {
	case lesson.EdgeChapter:
		return m.clearedchapter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LessonMutation) ClearEdge(name string) error {
	switch name {
	case lesson.EdgeChapter:
		m.ClearChapter()
		return nil
	}
	return fmt.Errorf("unknown Lesson unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LessonMutation) ResetEdge(name string) error {
	switch name {
	case lesson.EdgeChapter:
		m.ResetChapter()
		return nil
	}
	return fmt.Errorf("unknown Lesson edge %s", name)
}

// OrderInfosMutation represents an operation that mutates the OrderInfos nodes in the graph.
type OrderInfosMutation struct {
	config
	op               Op
	typ              string
	id               *int
	order_id         *int32
	addorder_id      *int32
	product_id       *int32
	addproduct_id    *int32
	product_name     *string
	product_price    *int32
	addproduct_price *int32
	product_describe *string
	create_time      *time.Time
	update_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*OrderInfos, error)
	predicates       []predicate.OrderInfos
}

var _ ent.Mutation = (*OrderInfosMutation)(nil)

// orderinfosOption allows management of the mutation configuration using functional options.
type orderinfosOption func(*OrderInfosMutation)

// newOrderInfosMutation creates new mutation for the OrderInfos entity.
func newOrderInfosMutation(c config, op Op, opts ...orderinfosOption) *OrderInfosMutation {
	m := &OrderInfosMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderInfos,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderInfosID sets the ID field of the mutation.
func withOrderInfosID(id int) orderinfosOption {
	return func(m *OrderInfosMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderInfos
		)
		m.oldValue = func(ctx context.Context) (*OrderInfos, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderInfos.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderInfos sets the old OrderInfos of the mutation.
func withOrderInfos(node *OrderInfos) orderinfosOption {
	return func(m *OrderInfosMutation) {
		m.oldValue = func(context.Context) (*OrderInfos, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderInfosMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderInfosMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderInfosMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderInfosMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderInfos.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *OrderInfosMutation) SetOrderID(i int32) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderInfosMutation) OrderID() (r int32, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldOrderID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *OrderInfosMutation) AddOrderID(i int32) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *OrderInfosMutation) AddedOrderID() (r int32, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderInfosMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetProductID sets the "product_id" field.
func (m *OrderInfosMutation) SetProductID(i int32) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderInfosMutation) ProductID() (r int32, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldProductID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderInfosMutation) AddProductID(i int32) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderInfosMutation) AddedProductID() (r int32, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderInfosMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetProductName sets the "product_name" field.
func (m *OrderInfosMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *OrderInfosMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName resets all changes to the "product_name" field.
func (m *OrderInfosMutation) ResetProductName() {
	m.product_name = nil
}

// SetProductPrice sets the "product_price" field.
func (m *OrderInfosMutation) SetProductPrice(i int32) {
	m.product_price = &i
	m.addproduct_price = nil
}

// ProductPrice returns the value of the "product_price" field in the mutation.
func (m *OrderInfosMutation) ProductPrice() (r int32, exists bool) {
	v := m.product_price
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPrice returns the old "product_price" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldProductPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPrice: %w", err)
	}
	return oldValue.ProductPrice, nil
}

// AddProductPrice adds i to the "product_price" field.
func (m *OrderInfosMutation) AddProductPrice(i int32) {
	if m.addproduct_price != nil {
		*m.addproduct_price += i
	} else {
		m.addproduct_price = &i
	}
}

// AddedProductPrice returns the value that was added to the "product_price" field in this mutation.
func (m *OrderInfosMutation) AddedProductPrice() (r int32, exists bool) {
	v := m.addproduct_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductPrice resets all changes to the "product_price" field.
func (m *OrderInfosMutation) ResetProductPrice() {
	m.product_price = nil
	m.addproduct_price = nil
}

// SetProductDescribe sets the "product_describe" field.
func (m *OrderInfosMutation) SetProductDescribe(s string) {
	m.product_describe = &s
}

// ProductDescribe returns the value of the "product_describe" field in the mutation.
func (m *OrderInfosMutation) ProductDescribe() (r string, exists bool) {
	v := m.product_describe
	if v == nil {
		return
	}
	return *v, true
}

// OldProductDescribe returns the old "product_describe" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldProductDescribe(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductDescribe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductDescribe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductDescribe: %w", err)
	}
	return oldValue.ProductDescribe, nil
}

// ResetProductDescribe resets all changes to the "product_describe" field.
func (m *OrderInfosMutation) ResetProductDescribe() {
	m.product_describe = nil
}

// SetCreateTime sets the "create_time" field.
func (m *OrderInfosMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderInfosMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderInfosMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderInfosMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderInfosMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderInfosMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the OrderInfosMutation builder.
func (m *OrderInfosMutation) Where(ps ...predicate.OrderInfos) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderInfosMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderInfosMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderInfos, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderInfosMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderInfosMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderInfos).
func (m *OrderInfosMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderInfosMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.order_id != nil {
		fields = append(fields, orderinfos.FieldOrderID)
	}
	if m.product_id != nil {
		fields = append(fields, orderinfos.FieldProductID)
	}
	if m.product_name != nil {
		fields = append(fields, orderinfos.FieldProductName)
	}
	if m.product_price != nil {
		fields = append(fields, orderinfos.FieldProductPrice)
	}
	if m.product_describe != nil {
		fields = append(fields, orderinfos.FieldProductDescribe)
	}
	if m.create_time != nil {
		fields = append(fields, orderinfos.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderinfos.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderInfosMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderinfos.FieldOrderID:
		return m.OrderID()
	case orderinfos.FieldProductID:
		return m.ProductID()
	case orderinfos.FieldProductName:
		return m.ProductName()
	case orderinfos.FieldProductPrice:
		return m.ProductPrice()
	case orderinfos.FieldProductDescribe:
		return m.ProductDescribe()
	case orderinfos.FieldCreateTime:
		return m.CreateTime()
	case orderinfos.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderInfosMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderinfos.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderinfos.FieldProductID:
		return m.OldProductID(ctx)
	case orderinfos.FieldProductName:
		return m.OldProductName(ctx)
	case orderinfos.FieldProductPrice:
		return m.OldProductPrice(ctx)
	case orderinfos.FieldProductDescribe:
		return m.OldProductDescribe(ctx)
	case orderinfos.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderinfos.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown OrderInfos field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderInfosMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderinfos.FieldOrderID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderinfos.FieldProductID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderinfos.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case orderinfos.FieldProductPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPrice(v)
		return nil
	case orderinfos.FieldProductDescribe:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductDescribe(v)
		return nil
	case orderinfos.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderinfos.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown OrderInfos field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderInfosMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, orderinfos.FieldOrderID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, orderinfos.FieldProductID)
	}
	if m.addproduct_price != nil {
		fields = append(fields, orderinfos.FieldProductPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderInfosMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderinfos.FieldOrderID:
		return m.AddedOrderID()
	case orderinfos.FieldProductID:
		return m.AddedProductID()
	case orderinfos.FieldProductPrice:
		return m.AddedProductPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderInfosMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderinfos.FieldOrderID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case orderinfos.FieldProductID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case orderinfos.FieldProductPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductPrice(v)
		return nil
	}
	return fmt.Errorf("unknown OrderInfos numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderInfosMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderInfosMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderInfosMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderInfos nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderInfosMutation) ResetField(name string) error {
	switch name {
	case orderinfos.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderinfos.FieldProductID:
		m.ResetProductID()
		return nil
	case orderinfos.FieldProductName:
		m.ResetProductName()
		return nil
	case orderinfos.FieldProductPrice:
		m.ResetProductPrice()
		return nil
	case orderinfos.FieldProductDescribe:
		m.ResetProductDescribe()
		return nil
	case orderinfos.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderinfos.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OrderInfos field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderInfosMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderInfosMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderInfosMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderInfosMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderInfosMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderInfosMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderInfosMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderInfos unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderInfosMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderInfos edge %s", name)
}

// OrdersMutation represents an operation that mutates the Orders nodes in the graph.
type OrdersMutation struct {
	config
	op             Op
	typ            string
	id             *int
	user_id        *int32
	adduser_id     *int32
	order_sn       *string
	pay_type       *int32
	addpay_type    *int32
	pay_status     *int32
	addpay_status  *int32
	trade_price    *int32
	addtrade_price *int32
	trade_no       *string
	pay_time       *time.Time
	create_time    *time.Time
	update_time    *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Orders, error)
	predicates     []predicate.Orders
}

var _ ent.Mutation = (*OrdersMutation)(nil)

// ordersOption allows management of the mutation configuration using functional options.
type ordersOption func(*OrdersMutation)

// newOrdersMutation creates new mutation for the Orders entity.
func newOrdersMutation(c config, op Op, opts ...ordersOption) *OrdersMutation {
	m := &OrdersMutation{
		config:        c,
		op:            op,
		typ:           TypeOrders,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrdersID sets the ID field of the mutation.
func withOrdersID(id int) ordersOption {
	return func(m *OrdersMutation) {
		var (
			err   error
			once  sync.Once
			value *Orders
		)
		m.oldValue = func(ctx context.Context) (*Orders, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Orders.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrders sets the old Orders of the mutation.
func withOrders(node *Orders) ordersOption {
	return func(m *OrdersMutation) {
		m.oldValue = func(context.Context) (*Orders, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrdersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrdersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrdersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrdersMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Orders.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *OrdersMutation) SetUserID(i int32) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrdersMutation) UserID() (r int32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldUserID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OrdersMutation) AddUserID(i int32) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OrdersMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrdersMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOrderSn sets the "order_sn" field.
func (m *OrdersMutation) SetOrderSn(s string) {
	m.order_sn = &s
}

// OrderSn returns the value of the "order_sn" field in the mutation.
func (m *OrdersMutation) OrderSn() (r string, exists bool) {
	v := m.order_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSn returns the old "order_sn" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldOrderSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSn: %w", err)
	}
	return oldValue.OrderSn, nil
}

// ResetOrderSn resets all changes to the "order_sn" field.
func (m *OrdersMutation) ResetOrderSn() {
	m.order_sn = nil
}

// SetPayType sets the "pay_type" field.
func (m *OrdersMutation) SetPayType(i int32) {
	m.pay_type = &i
	m.addpay_type = nil
}

// PayType returns the value of the "pay_type" field in the mutation.
func (m *OrdersMutation) PayType() (r int32, exists bool) {
	v := m.pay_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPayType returns the old "pay_type" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldPayType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayType: %w", err)
	}
	return oldValue.PayType, nil
}

// AddPayType adds i to the "pay_type" field.
func (m *OrdersMutation) AddPayType(i int32) {
	if m.addpay_type != nil {
		*m.addpay_type += i
	} else {
		m.addpay_type = &i
	}
}

// AddedPayType returns the value that was added to the "pay_type" field in this mutation.
func (m *OrdersMutation) AddedPayType() (r int32, exists bool) {
	v := m.addpay_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayType resets all changes to the "pay_type" field.
func (m *OrdersMutation) ResetPayType() {
	m.pay_type = nil
	m.addpay_type = nil
}

// SetPayStatus sets the "pay_status" field.
func (m *OrdersMutation) SetPayStatus(i int32) {
	m.pay_status = &i
	m.addpay_status = nil
}

// PayStatus returns the value of the "pay_status" field in the mutation.
func (m *OrdersMutation) PayStatus() (r int32, exists bool) {
	v := m.pay_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPayStatus returns the old "pay_status" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldPayStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayStatus: %w", err)
	}
	return oldValue.PayStatus, nil
}

// AddPayStatus adds i to the "pay_status" field.
func (m *OrdersMutation) AddPayStatus(i int32) {
	if m.addpay_status != nil {
		*m.addpay_status += i
	} else {
		m.addpay_status = &i
	}
}

// AddedPayStatus returns the value that was added to the "pay_status" field in this mutation.
func (m *OrdersMutation) AddedPayStatus() (r int32, exists bool) {
	v := m.addpay_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayStatus clears the value of the "pay_status" field.
func (m *OrdersMutation) ClearPayStatus() {
	m.pay_status = nil
	m.addpay_status = nil
	m.clearedFields[orders.FieldPayStatus] = struct{}{}
}

// PayStatusCleared returns if the "pay_status" field was cleared in this mutation.
func (m *OrdersMutation) PayStatusCleared() bool {
	_, ok := m.clearedFields[orders.FieldPayStatus]
	return ok
}

// ResetPayStatus resets all changes to the "pay_status" field.
func (m *OrdersMutation) ResetPayStatus() {
	m.pay_status = nil
	m.addpay_status = nil
	delete(m.clearedFields, orders.FieldPayStatus)
}

// SetTradePrice sets the "trade_price" field.
func (m *OrdersMutation) SetTradePrice(i int32) {
	m.trade_price = &i
	m.addtrade_price = nil
}

// TradePrice returns the value of the "trade_price" field in the mutation.
func (m *OrdersMutation) TradePrice() (r int32, exists bool) {
	v := m.trade_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTradePrice returns the old "trade_price" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldTradePrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradePrice: %w", err)
	}
	return oldValue.TradePrice, nil
}

// AddTradePrice adds i to the "trade_price" field.
func (m *OrdersMutation) AddTradePrice(i int32) {
	if m.addtrade_price != nil {
		*m.addtrade_price += i
	} else {
		m.addtrade_price = &i
	}
}

// AddedTradePrice returns the value that was added to the "trade_price" field in this mutation.
func (m *OrdersMutation) AddedTradePrice() (r int32, exists bool) {
	v := m.addtrade_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTradePrice resets all changes to the "trade_price" field.
func (m *OrdersMutation) ResetTradePrice() {
	m.trade_price = nil
	m.addtrade_price = nil
}

// SetTradeNo sets the "trade_no" field.
func (m *OrdersMutation) SetTradeNo(s string) {
	m.trade_no = &s
}

// TradeNo returns the value of the "trade_no" field in the mutation.
func (m *OrdersMutation) TradeNo() (r string, exists bool) {
	v := m.trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeNo returns the old "trade_no" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldTradeNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeNo: %w", err)
	}
	return oldValue.TradeNo, nil
}

// ClearTradeNo clears the value of the "trade_no" field.
func (m *OrdersMutation) ClearTradeNo() {
	m.trade_no = nil
	m.clearedFields[orders.FieldTradeNo] = struct{}{}
}

// TradeNoCleared returns if the "trade_no" field was cleared in this mutation.
func (m *OrdersMutation) TradeNoCleared() bool {
	_, ok := m.clearedFields[orders.FieldTradeNo]
	return ok
}

// ResetTradeNo resets all changes to the "trade_no" field.
func (m *OrdersMutation) ResetTradeNo() {
	m.trade_no = nil
	delete(m.clearedFields, orders.FieldTradeNo)
}

// SetPayTime sets the "pay_time" field.
func (m *OrdersMutation) SetPayTime(t time.Time) {
	m.pay_time = &t
}

// PayTime returns the value of the "pay_time" field in the mutation.
func (m *OrdersMutation) PayTime() (r time.Time, exists bool) {
	v := m.pay_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPayTime returns the old "pay_time" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldPayTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayTime: %w", err)
	}
	return oldValue.PayTime, nil
}

// ClearPayTime clears the value of the "pay_time" field.
func (m *OrdersMutation) ClearPayTime() {
	m.pay_time = nil
	m.clearedFields[orders.FieldPayTime] = struct{}{}
}

// PayTimeCleared returns if the "pay_time" field was cleared in this mutation.
func (m *OrdersMutation) PayTimeCleared() bool {
	_, ok := m.clearedFields[orders.FieldPayTime]
	return ok
}

// ResetPayTime resets all changes to the "pay_time" field.
func (m *OrdersMutation) ResetPayTime() {
	m.pay_time = nil
	delete(m.clearedFields, orders.FieldPayTime)
}

// SetCreateTime sets the "create_time" field.
func (m *OrdersMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrdersMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrdersMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrdersMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrdersMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrdersMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the OrdersMutation builder.
func (m *OrdersMutation) Where(ps ...predicate.Orders) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrdersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrdersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Orders, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrdersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrdersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Orders).
func (m *OrdersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrdersMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user_id != nil {
		fields = append(fields, orders.FieldUserID)
	}
	if m.order_sn != nil {
		fields = append(fields, orders.FieldOrderSn)
	}
	if m.pay_type != nil {
		fields = append(fields, orders.FieldPayType)
	}
	if m.pay_status != nil {
		fields = append(fields, orders.FieldPayStatus)
	}
	if m.trade_price != nil {
		fields = append(fields, orders.FieldTradePrice)
	}
	if m.trade_no != nil {
		fields = append(fields, orders.FieldTradeNo)
	}
	if m.pay_time != nil {
		fields = append(fields, orders.FieldPayTime)
	}
	if m.create_time != nil {
		fields = append(fields, orders.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orders.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrdersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orders.FieldUserID:
		return m.UserID()
	case orders.FieldOrderSn:
		return m.OrderSn()
	case orders.FieldPayType:
		return m.PayType()
	case orders.FieldPayStatus:
		return m.PayStatus()
	case orders.FieldTradePrice:
		return m.TradePrice()
	case orders.FieldTradeNo:
		return m.TradeNo()
	case orders.FieldPayTime:
		return m.PayTime()
	case orders.FieldCreateTime:
		return m.CreateTime()
	case orders.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrdersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orders.FieldUserID:
		return m.OldUserID(ctx)
	case orders.FieldOrderSn:
		return m.OldOrderSn(ctx)
	case orders.FieldPayType:
		return m.OldPayType(ctx)
	case orders.FieldPayStatus:
		return m.OldPayStatus(ctx)
	case orders.FieldTradePrice:
		return m.OldTradePrice(ctx)
	case orders.FieldTradeNo:
		return m.OldTradeNo(ctx)
	case orders.FieldPayTime:
		return m.OldPayTime(ctx)
	case orders.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orders.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Orders field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrdersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orders.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orders.FieldOrderSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSn(v)
		return nil
	case orders.FieldPayType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayType(v)
		return nil
	case orders.FieldPayStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayStatus(v)
		return nil
	case orders.FieldTradePrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradePrice(v)
		return nil
	case orders.FieldTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeNo(v)
		return nil
	case orders.FieldPayTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayTime(v)
		return nil
	case orders.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orders.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Orders field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrdersMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, orders.FieldUserID)
	}
	if m.addpay_type != nil {
		fields = append(fields, orders.FieldPayType)
	}
	if m.addpay_status != nil {
		fields = append(fields, orders.FieldPayStatus)
	}
	if m.addtrade_price != nil {
		fields = append(fields, orders.FieldTradePrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrdersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orders.FieldUserID:
		return m.AddedUserID()
	case orders.FieldPayType:
		return m.AddedPayType()
	case orders.FieldPayStatus:
		return m.AddedPayStatus()
	case orders.FieldTradePrice:
		return m.AddedTradePrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrdersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orders.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case orders.FieldPayType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayType(v)
		return nil
	case orders.FieldPayStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayStatus(v)
		return nil
	case orders.FieldTradePrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTradePrice(v)
		return nil
	}
	return fmt.Errorf("unknown Orders numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrdersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orders.FieldPayStatus) {
		fields = append(fields, orders.FieldPayStatus)
	}
	if m.FieldCleared(orders.FieldTradeNo) {
		fields = append(fields, orders.FieldTradeNo)
	}
	if m.FieldCleared(orders.FieldPayTime) {
		fields = append(fields, orders.FieldPayTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrdersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrdersMutation) ClearField(name string) error {
	switch name {
	case orders.FieldPayStatus:
		m.ClearPayStatus()
		return nil
	case orders.FieldTradeNo:
		m.ClearTradeNo()
		return nil
	case orders.FieldPayTime:
		m.ClearPayTime()
		return nil
	}
	return fmt.Errorf("unknown Orders nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrdersMutation) ResetField(name string) error {
	switch name {
	case orders.FieldUserID:
		m.ResetUserID()
		return nil
	case orders.FieldOrderSn:
		m.ResetOrderSn()
		return nil
	case orders.FieldPayType:
		m.ResetPayType()
		return nil
	case orders.FieldPayStatus:
		m.ResetPayStatus()
		return nil
	case orders.FieldTradePrice:
		m.ResetTradePrice()
		return nil
	case orders.FieldTradeNo:
		m.ResetTradeNo()
		return nil
	case orders.FieldPayTime:
		m.ResetPayTime()
		return nil
	case orders.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orders.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Orders field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrdersMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrdersMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrdersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrdersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrdersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrdersMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrdersMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Orders unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrdersMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Orders edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	detail        *string
	cover         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SettingMutation) ResetName() {
	m.name = nil
}

// SetDetail sets the "detail" field.
func (m *SettingMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *SettingMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *SettingMutation) ResetDetail() {
	m.detail = nil
}

// SetCover sets the "cover" field.
func (m *SettingMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *SettingMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ResetCover resets all changes to the "cover" field.
func (m *SettingMutation) ResetCover() {
	m.cover = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, setting.FieldName)
	}
	if m.detail != nil {
		fields = append(fields, setting.FieldDetail)
	}
	if m.cover != nil {
		fields = append(fields, setting.FieldCover)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldName:
		return m.Name()
	case setting.FieldDetail:
		return m.Detail()
	case setting.FieldCover:
		return m.Cover()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldName:
		return m.OldName(ctx)
	case setting.FieldDetail:
		return m.OldDetail(ctx)
	case setting.FieldCover:
		return m.OldCover(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case setting.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case setting.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldName:
		m.ResetName()
		return nil
	case setting.FieldDetail:
		m.ResetDetail()
		return nil
	case setting.FieldCover:
		m.ResetCover()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// SliderMutation represents an operation that mutates the Slider nodes in the graph.
type SliderMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	content       *string
	image_link    *string
	create_at     *time.Time
	update_at     *time.Time
	is_valid      *bool
	priority      *int
	addpriority   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Slider, error)
	predicates    []predicate.Slider
}

var _ ent.Mutation = (*SliderMutation)(nil)

// sliderOption allows management of the mutation configuration using functional options.
type sliderOption func(*SliderMutation)

// newSliderMutation creates new mutation for the Slider entity.
func newSliderMutation(c config, op Op, opts ...sliderOption) *SliderMutation {
	m := &SliderMutation{
		config:        c,
		op:            op,
		typ:           TypeSlider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSliderID sets the ID field of the mutation.
func withSliderID(id int) sliderOption {
	return func(m *SliderMutation) {
		var (
			err   error
			once  sync.Once
			value *Slider
		)
		m.oldValue = func(ctx context.Context) (*Slider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Slider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSlider sets the old Slider of the mutation.
func withSlider(node *Slider) sliderOption {
	return func(m *SliderMutation) {
		m.oldValue = func(context.Context) (*Slider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SliderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SliderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SliderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SliderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Slider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *SliderMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SliderMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SliderMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *SliderMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SliderMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *SliderMutation) ResetContent() {
	m.content = nil
}

// SetImageLink sets the "image_link" field.
func (m *SliderMutation) SetImageLink(s string) {
	m.image_link = &s
}

// ImageLink returns the value of the "image_link" field in the mutation.
func (m *SliderMutation) ImageLink() (r string, exists bool) {
	v := m.image_link
	if v == nil {
		return
	}
	return *v, true
}

// OldImageLink returns the old "image_link" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldImageLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageLink: %w", err)
	}
	return oldValue.ImageLink, nil
}

// ResetImageLink resets all changes to the "image_link" field.
func (m *SliderMutation) ResetImageLink() {
	m.image_link = nil
}

// SetCreateAt sets the "create_at" field.
func (m *SliderMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *SliderMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *SliderMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *SliderMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *SliderMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *SliderMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetIsValid sets the "is_valid" field.
func (m *SliderMutation) SetIsValid(b bool) {
	m.is_valid = &b
}

// IsValid returns the value of the "is_valid" field in the mutation.
func (m *SliderMutation) IsValid() (r bool, exists bool) {
	v := m.is_valid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsValid returns the old "is_valid" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldIsValid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsValid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsValid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsValid: %w", err)
	}
	return oldValue.IsValid, nil
}

// ResetIsValid resets all changes to the "is_valid" field.
func (m *SliderMutation) ResetIsValid() {
	m.is_valid = nil
}

// SetPriority sets the "priority" field.
func (m *SliderMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *SliderMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *SliderMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *SliderMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *SliderMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// Where appends a list predicates to the SliderMutation builder.
func (m *SliderMutation) Where(ps ...predicate.Slider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SliderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SliderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Slider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SliderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SliderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Slider).
func (m *SliderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SliderMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.title != nil {
		fields = append(fields, slider.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, slider.FieldContent)
	}
	if m.image_link != nil {
		fields = append(fields, slider.FieldImageLink)
	}
	if m.create_at != nil {
		fields = append(fields, slider.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, slider.FieldUpdateAt)
	}
	if m.is_valid != nil {
		fields = append(fields, slider.FieldIsValid)
	}
	if m.priority != nil {
		fields = append(fields, slider.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SliderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slider.FieldTitle:
		return m.Title()
	case slider.FieldContent:
		return m.Content()
	case slider.FieldImageLink:
		return m.ImageLink()
	case slider.FieldCreateAt:
		return m.CreateAt()
	case slider.FieldUpdateAt:
		return m.UpdateAt()
	case slider.FieldIsValid:
		return m.IsValid()
	case slider.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SliderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slider.FieldTitle:
		return m.OldTitle(ctx)
	case slider.FieldContent:
		return m.OldContent(ctx)
	case slider.FieldImageLink:
		return m.OldImageLink(ctx)
	case slider.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case slider.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case slider.FieldIsValid:
		return m.OldIsValid(ctx)
	case slider.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Slider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SliderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slider.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case slider.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case slider.FieldImageLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageLink(v)
		return nil
	case slider.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case slider.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case slider.FieldIsValid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsValid(v)
		return nil
	case slider.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Slider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SliderMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, slider.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SliderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case slider.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SliderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case slider.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Slider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SliderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SliderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SliderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Slider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SliderMutation) ResetField(name string) error {
	switch name {
	case slider.FieldTitle:
		m.ResetTitle()
		return nil
	case slider.FieldContent:
		m.ResetContent()
		return nil
	case slider.FieldImageLink:
		m.ResetImageLink()
		return nil
	case slider.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case slider.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case slider.FieldIsValid:
		m.ResetIsValid()
		return nil
	case slider.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Slider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SliderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SliderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SliderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SliderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SliderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SliderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SliderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Slider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SliderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Slider edge %s", name)
}

// TeacherMutation represents an operation that mutates the Teacher nodes in the graph.
type TeacherMutation struct {
	config
	op               Op
	typ              string
	id               *int
	detail           *string
	curriculum_vitae *string
	works            *string
	skills           *string
	name             *string
	level            *int
	addlevel         *int
	avator           *string
	create_at        *time.Time
	update_at        *time.Time
	clearedFields    map[string]struct{}
	courses          map[int]struct{}
	removedcourses   map[int]struct{}
	clearedcourses   bool
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Teacher, error)
	predicates       []predicate.Teacher
}

var _ ent.Mutation = (*TeacherMutation)(nil)

// teacherOption allows management of the mutation configuration using functional options.
type teacherOption func(*TeacherMutation)

// newTeacherMutation creates new mutation for the Teacher entity.
func newTeacherMutation(c config, op Op, opts ...teacherOption) *TeacherMutation {
	m := &TeacherMutation{
		config:        c,
		op:            op,
		typ:           TypeTeacher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeacherID sets the ID field of the mutation.
func withTeacherID(id int) teacherOption {
	return func(m *TeacherMutation) {
		var (
			err   error
			once  sync.Once
			value *Teacher
		)
		m.oldValue = func(ctx context.Context) (*Teacher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Teacher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeacher sets the old Teacher of the mutation.
func withTeacher(node *Teacher) teacherOption {
	return func(m *TeacherMutation) {
		m.oldValue = func(context.Context) (*Teacher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeacherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeacherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeacherMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeacherMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Teacher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDetail sets the "detail" field.
func (m *TeacherMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *TeacherMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *TeacherMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[teacher.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *TeacherMutation) DetailCleared() bool {
	_, ok := m.clearedFields[teacher.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *TeacherMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, teacher.FieldDetail)
}

// SetCurriculumVitae sets the "curriculum_vitae" field.
func (m *TeacherMutation) SetCurriculumVitae(s string) {
	m.curriculum_vitae = &s
}

// CurriculumVitae returns the value of the "curriculum_vitae" field in the mutation.
func (m *TeacherMutation) CurriculumVitae() (r string, exists bool) {
	v := m.curriculum_vitae
	if v == nil {
		return
	}
	return *v, true
}

// OldCurriculumVitae returns the old "curriculum_vitae" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldCurriculumVitae(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurriculumVitae is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurriculumVitae requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurriculumVitae: %w", err)
	}
	return oldValue.CurriculumVitae, nil
}

// ClearCurriculumVitae clears the value of the "curriculum_vitae" field.
func (m *TeacherMutation) ClearCurriculumVitae() {
	m.curriculum_vitae = nil
	m.clearedFields[teacher.FieldCurriculumVitae] = struct{}{}
}

// CurriculumVitaeCleared returns if the "curriculum_vitae" field was cleared in this mutation.
func (m *TeacherMutation) CurriculumVitaeCleared() bool {
	_, ok := m.clearedFields[teacher.FieldCurriculumVitae]
	return ok
}

// ResetCurriculumVitae resets all changes to the "curriculum_vitae" field.
func (m *TeacherMutation) ResetCurriculumVitae() {
	m.curriculum_vitae = nil
	delete(m.clearedFields, teacher.FieldCurriculumVitae)
}

// SetWorks sets the "works" field.
func (m *TeacherMutation) SetWorks(s string) {
	m.works = &s
}

// Works returns the value of the "works" field in the mutation.
func (m *TeacherMutation) Works() (r string, exists bool) {
	v := m.works
	if v == nil {
		return
	}
	return *v, true
}

// OldWorks returns the old "works" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldWorks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorks: %w", err)
	}
	return oldValue.Works, nil
}

// ClearWorks clears the value of the "works" field.
func (m *TeacherMutation) ClearWorks() {
	m.works = nil
	m.clearedFields[teacher.FieldWorks] = struct{}{}
}

// WorksCleared returns if the "works" field was cleared in this mutation.
func (m *TeacherMutation) WorksCleared() bool {
	_, ok := m.clearedFields[teacher.FieldWorks]
	return ok
}

// ResetWorks resets all changes to the "works" field.
func (m *TeacherMutation) ResetWorks() {
	m.works = nil
	delete(m.clearedFields, teacher.FieldWorks)
}

// SetSkills sets the "skills" field.
func (m *TeacherMutation) SetSkills(s string) {
	m.skills = &s
}

// Skills returns the value of the "skills" field in the mutation.
func (m *TeacherMutation) Skills() (r string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldSkills(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// ClearSkills clears the value of the "skills" field.
func (m *TeacherMutation) ClearSkills() {
	m.skills = nil
	m.clearedFields[teacher.FieldSkills] = struct{}{}
}

// SkillsCleared returns if the "skills" field was cleared in this mutation.
func (m *TeacherMutation) SkillsCleared() bool {
	_, ok := m.clearedFields[teacher.FieldSkills]
	return ok
}

// ResetSkills resets all changes to the "skills" field.
func (m *TeacherMutation) ResetSkills() {
	m.skills = nil
	delete(m.clearedFields, teacher.FieldSkills)
}

// SetName sets the "name" field.
func (m *TeacherMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeacherMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeacherMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *TeacherMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *TeacherMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *TeacherMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *TeacherMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *TeacherMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetAvator sets the "avator" field.
func (m *TeacherMutation) SetAvator(s string) {
	m.avator = &s
}

// Avator returns the value of the "avator" field in the mutation.
func (m *TeacherMutation) Avator() (r string, exists bool) {
	v := m.avator
	if v == nil {
		return
	}
	return *v, true
}

// OldAvator returns the old "avator" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldAvator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvator: %w", err)
	}
	return oldValue.Avator, nil
}

// ClearAvator clears the value of the "avator" field.
func (m *TeacherMutation) ClearAvator() {
	m.avator = nil
	m.clearedFields[teacher.FieldAvator] = struct{}{}
}

// AvatorCleared returns if the "avator" field was cleared in this mutation.
func (m *TeacherMutation) AvatorCleared() bool {
	_, ok := m.clearedFields[teacher.FieldAvator]
	return ok
}

// ResetAvator resets all changes to the "avator" field.
func (m *TeacherMutation) ResetAvator() {
	m.avator = nil
	delete(m.clearedFields, teacher.FieldAvator)
}

// SetCreateAt sets the "create_at" field.
func (m *TeacherMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *TeacherMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *TeacherMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *TeacherMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *TeacherMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *TeacherMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetUserID sets the "user_id" field.
func (m *TeacherMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TeacherMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *TeacherMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[teacher.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TeacherMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[teacher.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TeacherMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, teacher.FieldUserID)
}

// AddCourseIDs adds the "courses" edge to the Course entity by ids.
func (m *TeacherMutation) AddCourseIDs(ids ...int) {
	if m.courses == nil {
		m.courses = make(map[int]struct{})
	}
	for i := range ids {
		m.courses[ids[i]] = struct{}{}
	}
}

// ClearCourses clears the "courses" edge to the Course entity.
func (m *TeacherMutation) ClearCourses() {
	m.clearedcourses = true
}

// CoursesCleared reports if the "courses" edge to the Course entity was cleared.
func (m *TeacherMutation) CoursesCleared() bool {
	return m.clearedcourses
}

// RemoveCourseIDs removes the "courses" edge to the Course entity by IDs.
func (m *TeacherMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourses == nil {
		m.removedcourses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.courses, ids[i])
		m.removedcourses[ids[i]] = struct{}{}
	}
}

// RemovedCourses returns the removed IDs of the "courses" edge to the Course entity.
func (m *TeacherMutation) RemovedCoursesIDs() (ids []int) {
	for id := range m.removedcourses {
		ids = append(ids, id)
	}
	return
}

// CoursesIDs returns the "courses" edge IDs in the mutation.
func (m *TeacherMutation) CoursesIDs() (ids []int) {
	for id := range m.courses {
		ids = append(ids, id)
	}
	return
}

// ResetCourses resets all changes to the "courses" edge.
func (m *TeacherMutation) ResetCourses() {
	m.courses = nil
	m.clearedcourses = false
	m.removedcourses = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *TeacherMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TeacherMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TeacherMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TeacherMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TeacherMutation builder.
func (m *TeacherMutation) Where(ps ...predicate.Teacher) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeacherMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeacherMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Teacher, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeacherMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeacherMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Teacher).
func (m *TeacherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeacherMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.detail != nil {
		fields = append(fields, teacher.FieldDetail)
	}
	if m.curriculum_vitae != nil {
		fields = append(fields, teacher.FieldCurriculumVitae)
	}
	if m.works != nil {
		fields = append(fields, teacher.FieldWorks)
	}
	if m.skills != nil {
		fields = append(fields, teacher.FieldSkills)
	}
	if m.name != nil {
		fields = append(fields, teacher.FieldName)
	}
	if m.level != nil {
		fields = append(fields, teacher.FieldLevel)
	}
	if m.avator != nil {
		fields = append(fields, teacher.FieldAvator)
	}
	if m.create_at != nil {
		fields = append(fields, teacher.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, teacher.FieldUpdateAt)
	}
	if m.user != nil {
		fields = append(fields, teacher.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeacherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teacher.FieldDetail:
		return m.Detail()
	case teacher.FieldCurriculumVitae:
		return m.CurriculumVitae()
	case teacher.FieldWorks:
		return m.Works()
	case teacher.FieldSkills:
		return m.Skills()
	case teacher.FieldName:
		return m.Name()
	case teacher.FieldLevel:
		return m.Level()
	case teacher.FieldAvator:
		return m.Avator()
	case teacher.FieldCreateAt:
		return m.CreateAt()
	case teacher.FieldUpdateAt:
		return m.UpdateAt()
	case teacher.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeacherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teacher.FieldDetail:
		return m.OldDetail(ctx)
	case teacher.FieldCurriculumVitae:
		return m.OldCurriculumVitae(ctx)
	case teacher.FieldWorks:
		return m.OldWorks(ctx)
	case teacher.FieldSkills:
		return m.OldSkills(ctx)
	case teacher.FieldName:
		return m.OldName(ctx)
	case teacher.FieldLevel:
		return m.OldLevel(ctx)
	case teacher.FieldAvator:
		return m.OldAvator(ctx)
	case teacher.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case teacher.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case teacher.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Teacher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teacher.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case teacher.FieldCurriculumVitae:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurriculumVitae(v)
		return nil
	case teacher.FieldWorks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorks(v)
		return nil
	case teacher.FieldSkills:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case teacher.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teacher.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case teacher.FieldAvator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvator(v)
		return nil
	case teacher.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case teacher.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case teacher.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeacherMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, teacher.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeacherMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case teacher.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) AddField(name string, value ent.Value) error {
	switch name {
	case teacher.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Teacher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeacherMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teacher.FieldDetail) {
		fields = append(fields, teacher.FieldDetail)
	}
	if m.FieldCleared(teacher.FieldCurriculumVitae) {
		fields = append(fields, teacher.FieldCurriculumVitae)
	}
	if m.FieldCleared(teacher.FieldWorks) {
		fields = append(fields, teacher.FieldWorks)
	}
	if m.FieldCleared(teacher.FieldSkills) {
		fields = append(fields, teacher.FieldSkills)
	}
	if m.FieldCleared(teacher.FieldAvator) {
		fields = append(fields, teacher.FieldAvator)
	}
	if m.FieldCleared(teacher.FieldUserID) {
		fields = append(fields, teacher.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeacherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeacherMutation) ClearField(name string) error {
	switch name {
	case teacher.FieldDetail:
		m.ClearDetail()
		return nil
	case teacher.FieldCurriculumVitae:
		m.ClearCurriculumVitae()
		return nil
	case teacher.FieldWorks:
		m.ClearWorks()
		return nil
	case teacher.FieldSkills:
		m.ClearSkills()
		return nil
	case teacher.FieldAvator:
		m.ClearAvator()
		return nil
	case teacher.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Teacher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeacherMutation) ResetField(name string) error {
	switch name {
	case teacher.FieldDetail:
		m.ResetDetail()
		return nil
	case teacher.FieldCurriculumVitae:
		m.ResetCurriculumVitae()
		return nil
	case teacher.FieldWorks:
		m.ResetWorks()
		return nil
	case teacher.FieldSkills:
		m.ResetSkills()
		return nil
	case teacher.FieldName:
		m.ResetName()
		return nil
	case teacher.FieldLevel:
		m.ResetLevel()
		return nil
	case teacher.FieldAvator:
		m.ResetAvator()
		return nil
	case teacher.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case teacher.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case teacher.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeacherMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.courses != nil {
		edges = append(edges, teacher.EdgeCourses)
	}
	if m.user != nil {
		edges = append(edges, teacher.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeacherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teacher.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.courses))
		for id := range m.courses {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeacherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcourses != nil {
		edges = append(edges, teacher.EdgeCourses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeacherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case teacher.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.removedcourses))
		for id := range m.removedcourses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeacherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcourses {
		edges = append(edges, teacher.EdgeCourses)
	}
	if m.cleareduser {
		edges = append(edges, teacher.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeacherMutation) EdgeCleared(name string) bool {
	switch name {
	case teacher.EdgeCourses:
		return m.clearedcourses
	case teacher.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeacherMutation) ClearEdge(name string) error {
	switch name {
	case teacher.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Teacher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeacherMutation) ResetEdge(name string) error {
	switch name {
	case teacher.EdgeCourses:
		m.ResetCourses()
		return nil
	case teacher.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Teacher edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	username            *string
	channel             *string
	role_id             *uint8
	addrole_id          *int8
	clearedFields       map[string]struct{}
	teacher             *int
	clearedteacher      bool
	apply_record        map[int]struct{}
	removedapply_record map[int]struct{}
	clearedapply_record bool
	vip_info            *int
	clearedvip_info     bool
	vip_order           map[int]struct{}
	removedvip_order    map[int]struct{}
	clearedvip_order    bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetChannel sets the "channel" field.
func (m *UserMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *UserMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *UserMutation) ResetChannel() {
	m.channel = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserMutation) SetRoleID(u uint8) {
	m.role_id = &u
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserMutation) RoleID() (r uint8, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoleID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds u to the "role_id" field.
func (m *UserMutation) AddRoleID(u int8) {
	if m.addrole_id != nil {
		*m.addrole_id += u
	} else {
		m.addrole_id = &u
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *UserMutation) AddedRoleID() (r int8, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetTeacherID sets the "teacher" edge to the Teacher entity by id.
func (m *UserMutation) SetTeacherID(id int) {
	m.teacher = &id
}

// ClearTeacher clears the "teacher" edge to the Teacher entity.
func (m *UserMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the Teacher entity was cleared.
func (m *UserMutation) TeacherCleared() bool {
	return m.clearedteacher
}

// TeacherID returns the "teacher" edge ID in the mutation.
func (m *UserMutation) TeacherID() (id int, exists bool) {
	if m.teacher != nil {
		return *m.teacher, true
	}
	return
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TeacherIDs() (ids []int) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *UserMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// AddApplyRecordIDs adds the "apply_record" edge to the ApplyRecord entity by ids.
func (m *UserMutation) AddApplyRecordIDs(ids ...int) {
	if m.apply_record == nil {
		m.apply_record = make(map[int]struct{})
	}
	for i := range ids {
		m.apply_record[ids[i]] = struct{}{}
	}
}

// ClearApplyRecord clears the "apply_record" edge to the ApplyRecord entity.
func (m *UserMutation) ClearApplyRecord() {
	m.clearedapply_record = true
}

// ApplyRecordCleared reports if the "apply_record" edge to the ApplyRecord entity was cleared.
func (m *UserMutation) ApplyRecordCleared() bool {
	return m.clearedapply_record
}

// RemoveApplyRecordIDs removes the "apply_record" edge to the ApplyRecord entity by IDs.
func (m *UserMutation) RemoveApplyRecordIDs(ids ...int) {
	if m.removedapply_record == nil {
		m.removedapply_record = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.apply_record, ids[i])
		m.removedapply_record[ids[i]] = struct{}{}
	}
}

// RemovedApplyRecord returns the removed IDs of the "apply_record" edge to the ApplyRecord entity.
func (m *UserMutation) RemovedApplyRecordIDs() (ids []int) {
	for id := range m.removedapply_record {
		ids = append(ids, id)
	}
	return
}

// ApplyRecordIDs returns the "apply_record" edge IDs in the mutation.
func (m *UserMutation) ApplyRecordIDs() (ids []int) {
	for id := range m.apply_record {
		ids = append(ids, id)
	}
	return
}

// ResetApplyRecord resets all changes to the "apply_record" edge.
func (m *UserMutation) ResetApplyRecord() {
	m.apply_record = nil
	m.clearedapply_record = false
	m.removedapply_record = nil
}

// SetVipInfoID sets the "vip_info" edge to the VipInfo entity by id.
func (m *UserMutation) SetVipInfoID(id int) {
	m.vip_info = &id
}

// ClearVipInfo clears the "vip_info" edge to the VipInfo entity.
func (m *UserMutation) ClearVipInfo() {
	m.clearedvip_info = true
}

// VipInfoCleared reports if the "vip_info" edge to the VipInfo entity was cleared.
func (m *UserMutation) VipInfoCleared() bool {
	return m.clearedvip_info
}

// VipInfoID returns the "vip_info" edge ID in the mutation.
func (m *UserMutation) VipInfoID() (id int, exists bool) {
	if m.vip_info != nil {
		return *m.vip_info, true
	}
	return
}

// VipInfoIDs returns the "vip_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VipInfoID instead. It exists only for internal usage by the builders.
func (m *UserMutation) VipInfoIDs() (ids []int) {
	if id := m.vip_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVipInfo resets all changes to the "vip_info" edge.
func (m *UserMutation) ResetVipInfo() {
	m.vip_info = nil
	m.clearedvip_info = false
}

// AddVipOrderIDs adds the "vip_order" edge to the VipOrder entity by ids.
func (m *UserMutation) AddVipOrderIDs(ids ...int) {
	if m.vip_order == nil {
		m.vip_order = make(map[int]struct{})
	}
	for i := range ids {
		m.vip_order[ids[i]] = struct{}{}
	}
}

// ClearVipOrder clears the "vip_order" edge to the VipOrder entity.
func (m *UserMutation) ClearVipOrder() {
	m.clearedvip_order = true
}

// VipOrderCleared reports if the "vip_order" edge to the VipOrder entity was cleared.
func (m *UserMutation) VipOrderCleared() bool {
	return m.clearedvip_order
}

// RemoveVipOrderIDs removes the "vip_order" edge to the VipOrder entity by IDs.
func (m *UserMutation) RemoveVipOrderIDs(ids ...int) {
	if m.removedvip_order == nil {
		m.removedvip_order = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vip_order, ids[i])
		m.removedvip_order[ids[i]] = struct{}{}
	}
}

// RemovedVipOrder returns the removed IDs of the "vip_order" edge to the VipOrder entity.
func (m *UserMutation) RemovedVipOrderIDs() (ids []int) {
	for id := range m.removedvip_order {
		ids = append(ids, id)
	}
	return
}

// VipOrderIDs returns the "vip_order" edge IDs in the mutation.
func (m *UserMutation) VipOrderIDs() (ids []int) {
	for id := range m.vip_order {
		ids = append(ids, id)
	}
	return
}

// ResetVipOrder resets all changes to the "vip_order" edge.
func (m *UserMutation) ResetVipOrder() {
	m.vip_order = nil
	m.clearedvip_order = false
	m.removedvip_order = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.channel != nil {
		fields = append(fields, user.FieldChannel)
	}
	if m.role_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldChannel:
		return m.Channel()
	case user.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldChannel:
		return m.OldChannel(ctx)
	case user.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addrole_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRoleID:
		return m.AddedRoleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldRoleID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldChannel:
		m.ResetChannel()
		return nil
	case user.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.teacher != nil {
		edges = append(edges, user.EdgeTeacher)
	}
	if m.apply_record != nil {
		edges = append(edges, user.EdgeApplyRecord)
	}
	if m.vip_info != nil {
		edges = append(edges, user.EdgeVipInfo)
	}
	if m.vip_order != nil {
		edges = append(edges, user.EdgeVipOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeApplyRecord:
		ids := make([]ent.Value, 0, len(m.apply_record))
		for id := range m.apply_record {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVipInfo:
		if id := m.vip_info; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeVipOrder:
		ids := make([]ent.Value, 0, len(m.vip_order))
		for id := range m.vip_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedapply_record != nil {
		edges = append(edges, user.EdgeApplyRecord)
	}
	if m.removedvip_order != nil {
		edges = append(edges, user.EdgeVipOrder)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeApplyRecord:
		ids := make([]ent.Value, 0, len(m.removedapply_record))
		for id := range m.removedapply_record {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVipOrder:
		ids := make([]ent.Value, 0, len(m.removedvip_order))
		for id := range m.removedvip_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedteacher {
		edges = append(edges, user.EdgeTeacher)
	}
	if m.clearedapply_record {
		edges = append(edges, user.EdgeApplyRecord)
	}
	if m.clearedvip_info {
		edges = append(edges, user.EdgeVipInfo)
	}
	if m.clearedvip_order {
		edges = append(edges, user.EdgeVipOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTeacher:
		return m.clearedteacher
	case user.EdgeApplyRecord:
		return m.clearedapply_record
	case user.EdgeVipInfo:
		return m.clearedvip_info
	case user.EdgeVipOrder:
		return m.clearedvip_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeTeacher:
		m.ClearTeacher()
		return nil
	case user.EdgeVipInfo:
		m.ClearVipInfo()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTeacher:
		m.ResetTeacher()
		return nil
	case user.EdgeApplyRecord:
		m.ResetApplyRecord()
		return nil
	case user.EdgeVipInfo:
		m.ResetVipInfo()
		return nil
	case user.EdgeVipOrder:
		m.ResetVipOrder()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VipInfoMutation represents an operation that mutates the VipInfo nodes in the graph.
type VipInfoMutation struct {
	config
	op               Op
	typ              string
	id               *int
	vip_type         *int8
	addvip_type      *int8
	start_at         *time.Time
	expire_at        *time.Time
	clearedFields    map[string]struct{}
	user_info        *int
	cleareduser_info bool
	done             bool
	oldValue         func(context.Context) (*VipInfo, error)
	predicates       []predicate.VipInfo
}

var _ ent.Mutation = (*VipInfoMutation)(nil)

// vipinfoOption allows management of the mutation configuration using functional options.
type vipinfoOption func(*VipInfoMutation)

// newVipInfoMutation creates new mutation for the VipInfo entity.
func newVipInfoMutation(c config, op Op, opts ...vipinfoOption) *VipInfoMutation {
	m := &VipInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeVipInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVipInfoID sets the ID field of the mutation.
func withVipInfoID(id int) vipinfoOption {
	return func(m *VipInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *VipInfo
		)
		m.oldValue = func(ctx context.Context) (*VipInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VipInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVipInfo sets the old VipInfo of the mutation.
func withVipInfo(node *VipInfo) vipinfoOption {
	return func(m *VipInfoMutation) {
		m.oldValue = func(context.Context) (*VipInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VipInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VipInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VipInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VipInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VipInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVipType sets the "vip_type" field.
func (m *VipInfoMutation) SetVipType(i int8) {
	m.vip_type = &i
	m.addvip_type = nil
}

// VipType returns the value of the "vip_type" field in the mutation.
func (m *VipInfoMutation) VipType() (r int8, exists bool) {
	v := m.vip_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVipType returns the old "vip_type" field's value of the VipInfo entity.
// If the VipInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipInfoMutation) OldVipType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipType: %w", err)
	}
	return oldValue.VipType, nil
}

// AddVipType adds i to the "vip_type" field.
func (m *VipInfoMutation) AddVipType(i int8) {
	if m.addvip_type != nil {
		*m.addvip_type += i
	} else {
		m.addvip_type = &i
	}
}

// AddedVipType returns the value that was added to the "vip_type" field in this mutation.
func (m *VipInfoMutation) AddedVipType() (r int8, exists bool) {
	v := m.addvip_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetVipType resets all changes to the "vip_type" field.
func (m *VipInfoMutation) ResetVipType() {
	m.vip_type = nil
	m.addvip_type = nil
}

// SetStartAt sets the "start_at" field.
func (m *VipInfoMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *VipInfoMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the VipInfo entity.
// If the VipInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipInfoMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *VipInfoMutation) ResetStartAt() {
	m.start_at = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *VipInfoMutation) SetExpireAt(t time.Time) {
	m.expire_at = &t
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *VipInfoMutation) ExpireAt() (r time.Time, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the VipInfo entity.
// If the VipInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipInfoMutation) OldExpireAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *VipInfoMutation) ResetExpireAt() {
	m.expire_at = nil
}

// SetUserID sets the "user_id" field.
func (m *VipInfoMutation) SetUserID(i int) {
	m.user_info = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VipInfoMutation) UserID() (r int, exists bool) {
	v := m.user_info
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VipInfo entity.
// If the VipInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipInfoMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VipInfoMutation) ResetUserID() {
	m.user_info = nil
}

// SetUserInfoID sets the "user_info" edge to the User entity by id.
func (m *VipInfoMutation) SetUserInfoID(id int) {
	m.user_info = &id
}

// ClearUserInfo clears the "user_info" edge to the User entity.
func (m *VipInfoMutation) ClearUserInfo() {
	m.cleareduser_info = true
}

// UserInfoCleared reports if the "user_info" edge to the User entity was cleared.
func (m *VipInfoMutation) UserInfoCleared() bool {
	return m.cleareduser_info
}

// UserInfoID returns the "user_info" edge ID in the mutation.
func (m *VipInfoMutation) UserInfoID() (id int, exists bool) {
	if m.user_info != nil {
		return *m.user_info, true
	}
	return
}

// UserInfoIDs returns the "user_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserInfoID instead. It exists only for internal usage by the builders.
func (m *VipInfoMutation) UserInfoIDs() (ids []int) {
	if id := m.user_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserInfo resets all changes to the "user_info" edge.
func (m *VipInfoMutation) ResetUserInfo() {
	m.user_info = nil
	m.cleareduser_info = false
}

// Where appends a list predicates to the VipInfoMutation builder.
func (m *VipInfoMutation) Where(ps ...predicate.VipInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VipInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VipInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VipInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VipInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VipInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VipInfo).
func (m *VipInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VipInfoMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.vip_type != nil {
		fields = append(fields, vipinfo.FieldVipType)
	}
	if m.start_at != nil {
		fields = append(fields, vipinfo.FieldStartAt)
	}
	if m.expire_at != nil {
		fields = append(fields, vipinfo.FieldExpireAt)
	}
	if m.user_info != nil {
		fields = append(fields, vipinfo.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VipInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vipinfo.FieldVipType:
		return m.VipType()
	case vipinfo.FieldStartAt:
		return m.StartAt()
	case vipinfo.FieldExpireAt:
		return m.ExpireAt()
	case vipinfo.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VipInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vipinfo.FieldVipType:
		return m.OldVipType(ctx)
	case vipinfo.FieldStartAt:
		return m.OldStartAt(ctx)
	case vipinfo.FieldExpireAt:
		return m.OldExpireAt(ctx)
	case vipinfo.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown VipInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VipInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vipinfo.FieldVipType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipType(v)
		return nil
	case vipinfo.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case vipinfo.FieldExpireAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	case vipinfo.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown VipInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VipInfoMutation) AddedFields() []string {
	var fields []string
	if m.addvip_type != nil {
		fields = append(fields, vipinfo.FieldVipType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VipInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vipinfo.FieldVipType:
		return m.AddedVipType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VipInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vipinfo.FieldVipType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVipType(v)
		return nil
	}
	return fmt.Errorf("unknown VipInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VipInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VipInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VipInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VipInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VipInfoMutation) ResetField(name string) error {
	switch name {
	case vipinfo.FieldVipType:
		m.ResetVipType()
		return nil
	case vipinfo.FieldStartAt:
		m.ResetStartAt()
		return nil
	case vipinfo.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	case vipinfo.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown VipInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VipInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_info != nil {
		edges = append(edges, vipinfo.EdgeUserInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VipInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vipinfo.EdgeUserInfo:
		if id := m.user_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VipInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VipInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VipInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_info {
		edges = append(edges, vipinfo.EdgeUserInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VipInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case vipinfo.EdgeUserInfo:
		return m.cleareduser_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VipInfoMutation) ClearEdge(name string) error {
	switch name {
	case vipinfo.EdgeUserInfo:
		m.ClearUserInfo()
		return nil
	}
	return fmt.Errorf("unknown VipInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VipInfoMutation) ResetEdge(name string) error {
	switch name {
	case vipinfo.EdgeUserInfo:
		m.ResetUserInfo()
		return nil
	}
	return fmt.Errorf("unknown VipInfo edge %s", name)
}

// VipOrderMutation represents an operation that mutates the VipOrder nodes in the graph.
type VipOrderMutation struct {
	config
	op                Op
	typ               string
	id                *int
	biz_id            *int64
	addbiz_id         *int64
	vip_type          *int8
	addvip_type       *int8
	pay_type          *int8
	addpay_type       *int8
	pay_status        *int8
	addpay_status     *int8
	create_at         *time.Time
	update_at         *time.Time
	price             *float64
	addprice          *float64
	clearedFields     map[string]struct{}
	user_order        *int
	cleareduser_order bool
	done              bool
	oldValue          func(context.Context) (*VipOrder, error)
	predicates        []predicate.VipOrder
}

var _ ent.Mutation = (*VipOrderMutation)(nil)

// viporderOption allows management of the mutation configuration using functional options.
type viporderOption func(*VipOrderMutation)

// newVipOrderMutation creates new mutation for the VipOrder entity.
func newVipOrderMutation(c config, op Op, opts ...viporderOption) *VipOrderMutation {
	m := &VipOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeVipOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVipOrderID sets the ID field of the mutation.
func withVipOrderID(id int) viporderOption {
	return func(m *VipOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *VipOrder
		)
		m.oldValue = func(ctx context.Context) (*VipOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VipOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVipOrder sets the old VipOrder of the mutation.
func withVipOrder(node *VipOrder) viporderOption {
	return func(m *VipOrderMutation) {
		m.oldValue = func(context.Context) (*VipOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VipOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VipOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VipOrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VipOrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VipOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBizID sets the "biz_id" field.
func (m *VipOrderMutation) SetBizID(i int64) {
	m.biz_id = &i
	m.addbiz_id = nil
}

// BizID returns the value of the "biz_id" field in the mutation.
func (m *VipOrderMutation) BizID() (r int64, exists bool) {
	v := m.biz_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBizID returns the old "biz_id" field's value of the VipOrder entity.
// If the VipOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipOrderMutation) OldBizID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizID: %w", err)
	}
	return oldValue.BizID, nil
}

// AddBizID adds i to the "biz_id" field.
func (m *VipOrderMutation) AddBizID(i int64) {
	if m.addbiz_id != nil {
		*m.addbiz_id += i
	} else {
		m.addbiz_id = &i
	}
}

// AddedBizID returns the value that was added to the "biz_id" field in this mutation.
func (m *VipOrderMutation) AddedBizID() (r int64, exists bool) {
	v := m.addbiz_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBizID resets all changes to the "biz_id" field.
func (m *VipOrderMutation) ResetBizID() {
	m.biz_id = nil
	m.addbiz_id = nil
}

// SetVipType sets the "vip_type" field.
func (m *VipOrderMutation) SetVipType(i int8) {
	m.vip_type = &i
	m.addvip_type = nil
}

// VipType returns the value of the "vip_type" field in the mutation.
func (m *VipOrderMutation) VipType() (r int8, exists bool) {
	v := m.vip_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVipType returns the old "vip_type" field's value of the VipOrder entity.
// If the VipOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipOrderMutation) OldVipType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipType: %w", err)
	}
	return oldValue.VipType, nil
}

// AddVipType adds i to the "vip_type" field.
func (m *VipOrderMutation) AddVipType(i int8) {
	if m.addvip_type != nil {
		*m.addvip_type += i
	} else {
		m.addvip_type = &i
	}
}

// AddedVipType returns the value that was added to the "vip_type" field in this mutation.
func (m *VipOrderMutation) AddedVipType() (r int8, exists bool) {
	v := m.addvip_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetVipType resets all changes to the "vip_type" field.
func (m *VipOrderMutation) ResetVipType() {
	m.vip_type = nil
	m.addvip_type = nil
}

// SetPayType sets the "pay_type" field.
func (m *VipOrderMutation) SetPayType(i int8) {
	m.pay_type = &i
	m.addpay_type = nil
}

// PayType returns the value of the "pay_type" field in the mutation.
func (m *VipOrderMutation) PayType() (r int8, exists bool) {
	v := m.pay_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPayType returns the old "pay_type" field's value of the VipOrder entity.
// If the VipOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipOrderMutation) OldPayType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayType: %w", err)
	}
	return oldValue.PayType, nil
}

// AddPayType adds i to the "pay_type" field.
func (m *VipOrderMutation) AddPayType(i int8) {
	if m.addpay_type != nil {
		*m.addpay_type += i
	} else {
		m.addpay_type = &i
	}
}

// AddedPayType returns the value that was added to the "pay_type" field in this mutation.
func (m *VipOrderMutation) AddedPayType() (r int8, exists bool) {
	v := m.addpay_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayType resets all changes to the "pay_type" field.
func (m *VipOrderMutation) ResetPayType() {
	m.pay_type = nil
	m.addpay_type = nil
}

// SetPayStatus sets the "pay_status" field.
func (m *VipOrderMutation) SetPayStatus(i int8) {
	m.pay_status = &i
	m.addpay_status = nil
}

// PayStatus returns the value of the "pay_status" field in the mutation.
func (m *VipOrderMutation) PayStatus() (r int8, exists bool) {
	v := m.pay_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPayStatus returns the old "pay_status" field's value of the VipOrder entity.
// If the VipOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipOrderMutation) OldPayStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayStatus: %w", err)
	}
	return oldValue.PayStatus, nil
}

// AddPayStatus adds i to the "pay_status" field.
func (m *VipOrderMutation) AddPayStatus(i int8) {
	if m.addpay_status != nil {
		*m.addpay_status += i
	} else {
		m.addpay_status = &i
	}
}

// AddedPayStatus returns the value that was added to the "pay_status" field in this mutation.
func (m *VipOrderMutation) AddedPayStatus() (r int8, exists bool) {
	v := m.addpay_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayStatus clears the value of the "pay_status" field.
func (m *VipOrderMutation) ClearPayStatus() {
	m.pay_status = nil
	m.addpay_status = nil
	m.clearedFields[viporder.FieldPayStatus] = struct{}{}
}

// PayStatusCleared returns if the "pay_status" field was cleared in this mutation.
func (m *VipOrderMutation) PayStatusCleared() bool {
	_, ok := m.clearedFields[viporder.FieldPayStatus]
	return ok
}

// ResetPayStatus resets all changes to the "pay_status" field.
func (m *VipOrderMutation) ResetPayStatus() {
	m.pay_status = nil
	m.addpay_status = nil
	delete(m.clearedFields, viporder.FieldPayStatus)
}

// SetCreateAt sets the "create_at" field.
func (m *VipOrderMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *VipOrderMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the VipOrder entity.
// If the VipOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipOrderMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *VipOrderMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *VipOrderMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *VipOrderMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the VipOrder entity.
// If the VipOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipOrderMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *VipOrderMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetUserID sets the "user_id" field.
func (m *VipOrderMutation) SetUserID(i int) {
	m.user_order = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VipOrderMutation) UserID() (r int, exists bool) {
	v := m.user_order
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VipOrder entity.
// If the VipOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipOrderMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *VipOrderMutation) ClearUserID() {
	m.user_order = nil
	m.clearedFields[viporder.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *VipOrderMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[viporder.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VipOrderMutation) ResetUserID() {
	m.user_order = nil
	delete(m.clearedFields, viporder.FieldUserID)
}

// SetPrice sets the "price" field.
func (m *VipOrderMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *VipOrderMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the VipOrder entity.
// If the VipOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipOrderMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *VipOrderMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *VipOrderMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *VipOrderMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetUserOrderID sets the "user_order" edge to the User entity by id.
func (m *VipOrderMutation) SetUserOrderID(id int) {
	m.user_order = &id
}

// ClearUserOrder clears the "user_order" edge to the User entity.
func (m *VipOrderMutation) ClearUserOrder() {
	m.cleareduser_order = true
}

// UserOrderCleared reports if the "user_order" edge to the User entity was cleared.
func (m *VipOrderMutation) UserOrderCleared() bool {
	return m.UserIDCleared() || m.cleareduser_order
}

// UserOrderID returns the "user_order" edge ID in the mutation.
func (m *VipOrderMutation) UserOrderID() (id int, exists bool) {
	if m.user_order != nil {
		return *m.user_order, true
	}
	return
}

// UserOrderIDs returns the "user_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserOrderID instead. It exists only for internal usage by the builders.
func (m *VipOrderMutation) UserOrderIDs() (ids []int) {
	if id := m.user_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserOrder resets all changes to the "user_order" edge.
func (m *VipOrderMutation) ResetUserOrder() {
	m.user_order = nil
	m.cleareduser_order = false
}

// Where appends a list predicates to the VipOrderMutation builder.
func (m *VipOrderMutation) Where(ps ...predicate.VipOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VipOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VipOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VipOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VipOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VipOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VipOrder).
func (m *VipOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VipOrderMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.biz_id != nil {
		fields = append(fields, viporder.FieldBizID)
	}
	if m.vip_type != nil {
		fields = append(fields, viporder.FieldVipType)
	}
	if m.pay_type != nil {
		fields = append(fields, viporder.FieldPayType)
	}
	if m.pay_status != nil {
		fields = append(fields, viporder.FieldPayStatus)
	}
	if m.create_at != nil {
		fields = append(fields, viporder.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, viporder.FieldUpdateAt)
	}
	if m.user_order != nil {
		fields = append(fields, viporder.FieldUserID)
	}
	if m.price != nil {
		fields = append(fields, viporder.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VipOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case viporder.FieldBizID:
		return m.BizID()
	case viporder.FieldVipType:
		return m.VipType()
	case viporder.FieldPayType:
		return m.PayType()
	case viporder.FieldPayStatus:
		return m.PayStatus()
	case viporder.FieldCreateAt:
		return m.CreateAt()
	case viporder.FieldUpdateAt:
		return m.UpdateAt()
	case viporder.FieldUserID:
		return m.UserID()
	case viporder.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VipOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case viporder.FieldBizID:
		return m.OldBizID(ctx)
	case viporder.FieldVipType:
		return m.OldVipType(ctx)
	case viporder.FieldPayType:
		return m.OldPayType(ctx)
	case viporder.FieldPayStatus:
		return m.OldPayStatus(ctx)
	case viporder.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case viporder.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case viporder.FieldUserID:
		return m.OldUserID(ctx)
	case viporder.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown VipOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VipOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case viporder.FieldBizID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizID(v)
		return nil
	case viporder.FieldVipType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipType(v)
		return nil
	case viporder.FieldPayType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayType(v)
		return nil
	case viporder.FieldPayStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayStatus(v)
		return nil
	case viporder.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case viporder.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case viporder.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case viporder.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown VipOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VipOrderMutation) AddedFields() []string {
	var fields []string
	if m.addbiz_id != nil {
		fields = append(fields, viporder.FieldBizID)
	}
	if m.addvip_type != nil {
		fields = append(fields, viporder.FieldVipType)
	}
	if m.addpay_type != nil {
		fields = append(fields, viporder.FieldPayType)
	}
	if m.addpay_status != nil {
		fields = append(fields, viporder.FieldPayStatus)
	}
	if m.addprice != nil {
		fields = append(fields, viporder.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VipOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case viporder.FieldBizID:
		return m.AddedBizID()
	case viporder.FieldVipType:
		return m.AddedVipType()
	case viporder.FieldPayType:
		return m.AddedPayType()
	case viporder.FieldPayStatus:
		return m.AddedPayStatus()
	case viporder.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VipOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case viporder.FieldBizID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBizID(v)
		return nil
	case viporder.FieldVipType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVipType(v)
		return nil
	case viporder.FieldPayType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayType(v)
		return nil
	case viporder.FieldPayStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayStatus(v)
		return nil
	case viporder.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown VipOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VipOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(viporder.FieldPayStatus) {
		fields = append(fields, viporder.FieldPayStatus)
	}
	if m.FieldCleared(viporder.FieldUserID) {
		fields = append(fields, viporder.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VipOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VipOrderMutation) ClearField(name string) error {
	switch name {
	case viporder.FieldPayStatus:
		m.ClearPayStatus()
		return nil
	case viporder.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown VipOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VipOrderMutation) ResetField(name string) error {
	switch name {
	case viporder.FieldBizID:
		m.ResetBizID()
		return nil
	case viporder.FieldVipType:
		m.ResetVipType()
		return nil
	case viporder.FieldPayType:
		m.ResetPayType()
		return nil
	case viporder.FieldPayStatus:
		m.ResetPayStatus()
		return nil
	case viporder.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case viporder.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case viporder.FieldUserID:
		m.ResetUserID()
		return nil
	case viporder.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown VipOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VipOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_order != nil {
		edges = append(edges, viporder.EdgeUserOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VipOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case viporder.EdgeUserOrder:
		if id := m.user_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VipOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VipOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VipOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_order {
		edges = append(edges, viporder.EdgeUserOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VipOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case viporder.EdgeUserOrder:
		return m.cleareduser_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VipOrderMutation) ClearEdge(name string) error {
	switch name {
	case viporder.EdgeUserOrder:
		m.ClearUserOrder()
		return nil
	}
	return fmt.Errorf("unknown VipOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VipOrderMutation) ResetEdge(name string) error {
	switch name {
	case viporder.EdgeUserOrder:
		m.ResetUserOrder()
		return nil
	}
	return fmt.Errorf("unknown VipOrder edge %s", name)
}

// VipProductMutation represents an operation that mutates the VipProduct nodes in the graph.
type VipProductMutation struct {
	config
	op            Op
	typ           string
	id            *int
	price         *float64
	addprice      *float64
	name          *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VipProduct, error)
	predicates    []predicate.VipProduct
}

var _ ent.Mutation = (*VipProductMutation)(nil)

// vipproductOption allows management of the mutation configuration using functional options.
type vipproductOption func(*VipProductMutation)

// newVipProductMutation creates new mutation for the VipProduct entity.
func newVipProductMutation(c config, op Op, opts ...vipproductOption) *VipProductMutation {
	m := &VipProductMutation{
		config:        c,
		op:            op,
		typ:           TypeVipProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVipProductID sets the ID field of the mutation.
func withVipProductID(id int) vipproductOption {
	return func(m *VipProductMutation) {
		var (
			err   error
			once  sync.Once
			value *VipProduct
		)
		m.oldValue = func(ctx context.Context) (*VipProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VipProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVipProduct sets the old VipProduct of the mutation.
func withVipProduct(node *VipProduct) vipproductOption {
	return func(m *VipProductMutation) {
		m.oldValue = func(context.Context) (*VipProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VipProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VipProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VipProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VipProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VipProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrice sets the "price" field.
func (m *VipProductMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *VipProductMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the VipProduct entity.
// If the VipProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipProductMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *VipProductMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *VipProductMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *VipProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetName sets the "name" field.
func (m *VipProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VipProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VipProduct entity.
// If the VipProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VipProductMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *VipProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VipProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the VipProduct entity.
// If the VipProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VipProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *VipProductMutation) ResetDescription() {
	m.description = nil
}

// Where appends a list predicates to the VipProductMutation builder.
func (m *VipProductMutation) Where(ps ...predicate.VipProduct) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VipProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VipProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VipProduct, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VipProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VipProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VipProduct).
func (m *VipProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VipProductMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.price != nil {
		fields = append(fields, vipproduct.FieldPrice)
	}
	if m.name != nil {
		fields = append(fields, vipproduct.FieldName)
	}
	if m.description != nil {
		fields = append(fields, vipproduct.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VipProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vipproduct.FieldPrice:
		return m.Price()
	case vipproduct.FieldName:
		return m.Name()
	case vipproduct.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VipProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vipproduct.FieldPrice:
		return m.OldPrice(ctx)
	case vipproduct.FieldName:
		return m.OldName(ctx)
	case vipproduct.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown VipProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VipProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vipproduct.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case vipproduct.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vipproduct.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown VipProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VipProductMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, vipproduct.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VipProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vipproduct.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VipProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vipproduct.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown VipProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VipProductMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VipProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VipProductMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VipProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VipProductMutation) ResetField(name string) error {
	switch name {
	case vipproduct.FieldPrice:
		m.ResetPrice()
		return nil
	case vipproduct.FieldName:
		m.ResetName()
		return nil
	case vipproduct.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown VipProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VipProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VipProductMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VipProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VipProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VipProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VipProductMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VipProductMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VipProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VipProductMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VipProduct edge %s", name)
}

// WalletMutation represents an operation that mutates the Wallet nodes in the graph.
type WalletMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	gold_leaf             *int32
	addgold_leaf          *int32
	silver_leaf           *int32
	addsilver_leaf        *int32
	frozen_gold_leaf      *int32
	addfrozen_gold_leaf   *int32
	frozen_silver_leaf    *int32
	addfrozen_silver_leaf *int32
	user_id               *int32
	adduser_id            *int32
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Wallet, error)
	predicates            []predicate.Wallet
}

var _ ent.Mutation = (*WalletMutation)(nil)

// walletOption allows management of the mutation configuration using functional options.
type walletOption func(*WalletMutation)

// newWalletMutation creates new mutation for the Wallet entity.
func newWalletMutation(c config, op Op, opts ...walletOption) *WalletMutation {
	m := &WalletMutation{
		config:        c,
		op:            op,
		typ:           TypeWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletID sets the ID field of the mutation.
func withWalletID(id int) walletOption {
	return func(m *WalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Wallet
		)
		m.oldValue = func(ctx context.Context) (*Wallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWallet sets the old Wallet of the mutation.
func withWallet(node *Wallet) walletOption {
	return func(m *WalletMutation) {
		m.oldValue = func(context.Context) (*Wallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGoldLeaf sets the "gold_leaf" field.
func (m *WalletMutation) SetGoldLeaf(i int32) {
	m.gold_leaf = &i
	m.addgold_leaf = nil
}

// GoldLeaf returns the value of the "gold_leaf" field in the mutation.
func (m *WalletMutation) GoldLeaf() (r int32, exists bool) {
	v := m.gold_leaf
	if v == nil {
		return
	}
	return *v, true
}

// OldGoldLeaf returns the old "gold_leaf" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldGoldLeaf(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoldLeaf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoldLeaf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoldLeaf: %w", err)
	}
	return oldValue.GoldLeaf, nil
}

// AddGoldLeaf adds i to the "gold_leaf" field.
func (m *WalletMutation) AddGoldLeaf(i int32) {
	if m.addgold_leaf != nil {
		*m.addgold_leaf += i
	} else {
		m.addgold_leaf = &i
	}
}

// AddedGoldLeaf returns the value that was added to the "gold_leaf" field in this mutation.
func (m *WalletMutation) AddedGoldLeaf() (r int32, exists bool) {
	v := m.addgold_leaf
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoldLeaf clears the value of the "gold_leaf" field.
func (m *WalletMutation) ClearGoldLeaf() {
	m.gold_leaf = nil
	m.addgold_leaf = nil
	m.clearedFields[wallet.FieldGoldLeaf] = struct{}{}
}

// GoldLeafCleared returns if the "gold_leaf" field was cleared in this mutation.
func (m *WalletMutation) GoldLeafCleared() bool {
	_, ok := m.clearedFields[wallet.FieldGoldLeaf]
	return ok
}

// ResetGoldLeaf resets all changes to the "gold_leaf" field.
func (m *WalletMutation) ResetGoldLeaf() {
	m.gold_leaf = nil
	m.addgold_leaf = nil
	delete(m.clearedFields, wallet.FieldGoldLeaf)
}

// SetSilverLeaf sets the "silver_leaf" field.
func (m *WalletMutation) SetSilverLeaf(i int32) {
	m.silver_leaf = &i
	m.addsilver_leaf = nil
}

// SilverLeaf returns the value of the "silver_leaf" field in the mutation.
func (m *WalletMutation) SilverLeaf() (r int32, exists bool) {
	v := m.silver_leaf
	if v == nil {
		return
	}
	return *v, true
}

// OldSilverLeaf returns the old "silver_leaf" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldSilverLeaf(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSilverLeaf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSilverLeaf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSilverLeaf: %w", err)
	}
	return oldValue.SilverLeaf, nil
}

// AddSilverLeaf adds i to the "silver_leaf" field.
func (m *WalletMutation) AddSilverLeaf(i int32) {
	if m.addsilver_leaf != nil {
		*m.addsilver_leaf += i
	} else {
		m.addsilver_leaf = &i
	}
}

// AddedSilverLeaf returns the value that was added to the "silver_leaf" field in this mutation.
func (m *WalletMutation) AddedSilverLeaf() (r int32, exists bool) {
	v := m.addsilver_leaf
	if v == nil {
		return
	}
	return *v, true
}

// ClearSilverLeaf clears the value of the "silver_leaf" field.
func (m *WalletMutation) ClearSilverLeaf() {
	m.silver_leaf = nil
	m.addsilver_leaf = nil
	m.clearedFields[wallet.FieldSilverLeaf] = struct{}{}
}

// SilverLeafCleared returns if the "silver_leaf" field was cleared in this mutation.
func (m *WalletMutation) SilverLeafCleared() bool {
	_, ok := m.clearedFields[wallet.FieldSilverLeaf]
	return ok
}

// ResetSilverLeaf resets all changes to the "silver_leaf" field.
func (m *WalletMutation) ResetSilverLeaf() {
	m.silver_leaf = nil
	m.addsilver_leaf = nil
	delete(m.clearedFields, wallet.FieldSilverLeaf)
}

// SetFrozenGoldLeaf sets the "frozen_gold_leaf" field.
func (m *WalletMutation) SetFrozenGoldLeaf(i int32) {
	m.frozen_gold_leaf = &i
	m.addfrozen_gold_leaf = nil
}

// FrozenGoldLeaf returns the value of the "frozen_gold_leaf" field in the mutation.
func (m *WalletMutation) FrozenGoldLeaf() (r int32, exists bool) {
	v := m.frozen_gold_leaf
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenGoldLeaf returns the old "frozen_gold_leaf" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldFrozenGoldLeaf(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenGoldLeaf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenGoldLeaf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenGoldLeaf: %w", err)
	}
	return oldValue.FrozenGoldLeaf, nil
}

// AddFrozenGoldLeaf adds i to the "frozen_gold_leaf" field.
func (m *WalletMutation) AddFrozenGoldLeaf(i int32) {
	if m.addfrozen_gold_leaf != nil {
		*m.addfrozen_gold_leaf += i
	} else {
		m.addfrozen_gold_leaf = &i
	}
}

// AddedFrozenGoldLeaf returns the value that was added to the "frozen_gold_leaf" field in this mutation.
func (m *WalletMutation) AddedFrozenGoldLeaf() (r int32, exists bool) {
	v := m.addfrozen_gold_leaf
	if v == nil {
		return
	}
	return *v, true
}

// ClearFrozenGoldLeaf clears the value of the "frozen_gold_leaf" field.
func (m *WalletMutation) ClearFrozenGoldLeaf() {
	m.frozen_gold_leaf = nil
	m.addfrozen_gold_leaf = nil
	m.clearedFields[wallet.FieldFrozenGoldLeaf] = struct{}{}
}

// FrozenGoldLeafCleared returns if the "frozen_gold_leaf" field was cleared in this mutation.
func (m *WalletMutation) FrozenGoldLeafCleared() bool {
	_, ok := m.clearedFields[wallet.FieldFrozenGoldLeaf]
	return ok
}

// ResetFrozenGoldLeaf resets all changes to the "frozen_gold_leaf" field.
func (m *WalletMutation) ResetFrozenGoldLeaf() {
	m.frozen_gold_leaf = nil
	m.addfrozen_gold_leaf = nil
	delete(m.clearedFields, wallet.FieldFrozenGoldLeaf)
}

// SetFrozenSilverLeaf sets the "frozen_silver_leaf" field.
func (m *WalletMutation) SetFrozenSilverLeaf(i int32) {
	m.frozen_silver_leaf = &i
	m.addfrozen_silver_leaf = nil
}

// FrozenSilverLeaf returns the value of the "frozen_silver_leaf" field in the mutation.
func (m *WalletMutation) FrozenSilverLeaf() (r int32, exists bool) {
	v := m.frozen_silver_leaf
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenSilverLeaf returns the old "frozen_silver_leaf" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldFrozenSilverLeaf(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenSilverLeaf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenSilverLeaf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenSilverLeaf: %w", err)
	}
	return oldValue.FrozenSilverLeaf, nil
}

// AddFrozenSilverLeaf adds i to the "frozen_silver_leaf" field.
func (m *WalletMutation) AddFrozenSilverLeaf(i int32) {
	if m.addfrozen_silver_leaf != nil {
		*m.addfrozen_silver_leaf += i
	} else {
		m.addfrozen_silver_leaf = &i
	}
}

// AddedFrozenSilverLeaf returns the value that was added to the "frozen_silver_leaf" field in this mutation.
func (m *WalletMutation) AddedFrozenSilverLeaf() (r int32, exists bool) {
	v := m.addfrozen_silver_leaf
	if v == nil {
		return
	}
	return *v, true
}

// ClearFrozenSilverLeaf clears the value of the "frozen_silver_leaf" field.
func (m *WalletMutation) ClearFrozenSilverLeaf() {
	m.frozen_silver_leaf = nil
	m.addfrozen_silver_leaf = nil
	m.clearedFields[wallet.FieldFrozenSilverLeaf] = struct{}{}
}

// FrozenSilverLeafCleared returns if the "frozen_silver_leaf" field was cleared in this mutation.
func (m *WalletMutation) FrozenSilverLeafCleared() bool {
	_, ok := m.clearedFields[wallet.FieldFrozenSilverLeaf]
	return ok
}

// ResetFrozenSilverLeaf resets all changes to the "frozen_silver_leaf" field.
func (m *WalletMutation) ResetFrozenSilverLeaf() {
	m.frozen_silver_leaf = nil
	m.addfrozen_silver_leaf = nil
	delete(m.clearedFields, wallet.FieldFrozenSilverLeaf)
}

// SetUserID sets the "user_id" field.
func (m *WalletMutation) SetUserID(i int32) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WalletMutation) UserID() (r int32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUserID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *WalletMutation) AddUserID(i int32) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *WalletMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *WalletMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[wallet.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *WalletMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[wallet.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WalletMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, wallet.FieldUserID)
}

// SetCreatedAt sets the "created_at" field.
func (m *WalletMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WalletMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WalletMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WalletMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WalletMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WalletMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the WalletMutation builder.
func (m *WalletMutation) Where(ps ...predicate.Wallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Wallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Wallet).
func (m *WalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.gold_leaf != nil {
		fields = append(fields, wallet.FieldGoldLeaf)
	}
	if m.silver_leaf != nil {
		fields = append(fields, wallet.FieldSilverLeaf)
	}
	if m.frozen_gold_leaf != nil {
		fields = append(fields, wallet.FieldFrozenGoldLeaf)
	}
	if m.frozen_silver_leaf != nil {
		fields = append(fields, wallet.FieldFrozenSilverLeaf)
	}
	if m.user_id != nil {
		fields = append(fields, wallet.FieldUserID)
	}
	if m.created_at != nil {
		fields = append(fields, wallet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, wallet.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldGoldLeaf:
		return m.GoldLeaf()
	case wallet.FieldSilverLeaf:
		return m.SilverLeaf()
	case wallet.FieldFrozenGoldLeaf:
		return m.FrozenGoldLeaf()
	case wallet.FieldFrozenSilverLeaf:
		return m.FrozenSilverLeaf()
	case wallet.FieldUserID:
		return m.UserID()
	case wallet.FieldCreatedAt:
		return m.CreatedAt()
	case wallet.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wallet.FieldGoldLeaf:
		return m.OldGoldLeaf(ctx)
	case wallet.FieldSilverLeaf:
		return m.OldSilverLeaf(ctx)
	case wallet.FieldFrozenGoldLeaf:
		return m.OldFrozenGoldLeaf(ctx)
	case wallet.FieldFrozenSilverLeaf:
		return m.OldFrozenSilverLeaf(ctx)
	case wallet.FieldUserID:
		return m.OldUserID(ctx)
	case wallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case wallet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Wallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldGoldLeaf:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoldLeaf(v)
		return nil
	case wallet.FieldSilverLeaf:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSilverLeaf(v)
		return nil
	case wallet.FieldFrozenGoldLeaf:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenGoldLeaf(v)
		return nil
	case wallet.FieldFrozenSilverLeaf:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenSilverLeaf(v)
		return nil
	case wallet.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case wallet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case wallet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletMutation) AddedFields() []string {
	var fields []string
	if m.addgold_leaf != nil {
		fields = append(fields, wallet.FieldGoldLeaf)
	}
	if m.addsilver_leaf != nil {
		fields = append(fields, wallet.FieldSilverLeaf)
	}
	if m.addfrozen_gold_leaf != nil {
		fields = append(fields, wallet.FieldFrozenGoldLeaf)
	}
	if m.addfrozen_silver_leaf != nil {
		fields = append(fields, wallet.FieldFrozenSilverLeaf)
	}
	if m.adduser_id != nil {
		fields = append(fields, wallet.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldGoldLeaf:
		return m.AddedGoldLeaf()
	case wallet.FieldSilverLeaf:
		return m.AddedSilverLeaf()
	case wallet.FieldFrozenGoldLeaf:
		return m.AddedFrozenGoldLeaf()
	case wallet.FieldFrozenSilverLeaf:
		return m.AddedFrozenSilverLeaf()
	case wallet.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldGoldLeaf:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoldLeaf(v)
		return nil
	case wallet.FieldSilverLeaf:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSilverLeaf(v)
		return nil
	case wallet.FieldFrozenGoldLeaf:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenGoldLeaf(v)
		return nil
	case wallet.FieldFrozenSilverLeaf:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenSilverLeaf(v)
		return nil
	case wallet.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wallet.FieldGoldLeaf) {
		fields = append(fields, wallet.FieldGoldLeaf)
	}
	if m.FieldCleared(wallet.FieldSilverLeaf) {
		fields = append(fields, wallet.FieldSilverLeaf)
	}
	if m.FieldCleared(wallet.FieldFrozenGoldLeaf) {
		fields = append(fields, wallet.FieldFrozenGoldLeaf)
	}
	if m.FieldCleared(wallet.FieldFrozenSilverLeaf) {
		fields = append(fields, wallet.FieldFrozenSilverLeaf)
	}
	if m.FieldCleared(wallet.FieldUserID) {
		fields = append(fields, wallet.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletMutation) ClearField(name string) error {
	switch name {
	case wallet.FieldGoldLeaf:
		m.ClearGoldLeaf()
		return nil
	case wallet.FieldSilverLeaf:
		m.ClearSilverLeaf()
		return nil
	case wallet.FieldFrozenGoldLeaf:
		m.ClearFrozenGoldLeaf()
		return nil
	case wallet.FieldFrozenSilverLeaf:
		m.ClearFrozenSilverLeaf()
		return nil
	case wallet.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Wallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletMutation) ResetField(name string) error {
	switch name {
	case wallet.FieldGoldLeaf:
		m.ResetGoldLeaf()
		return nil
	case wallet.FieldSilverLeaf:
		m.ResetSilverLeaf()
		return nil
	case wallet.FieldFrozenGoldLeaf:
		m.ResetFrozenGoldLeaf()
		return nil
	case wallet.FieldFrozenSilverLeaf:
		m.ResetFrozenSilverLeaf()
		return nil
	case wallet.FieldUserID:
		m.ResetUserID()
		return nil
	case wallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case wallet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Wallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Wallet edge %s", name)
}
